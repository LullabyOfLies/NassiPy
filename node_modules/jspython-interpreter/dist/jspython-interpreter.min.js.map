{"version":3,"file":"jspython-interpreter.min.js","sources":["../src/common/utils.ts","../src/common/operators.ts","../src/common/token-types.ts","../src/common/ast-types.ts","../src/evaluator/scope.ts","../src/evaluator/evaluator.ts","../src/evaluator/evaluatorAsync.ts","../src/initialScope.ts","../src/parser/parser.ts","../src/tokenizer/tokenizer.ts","../src/interpreter.ts"],"sourcesContent":["export function parseDatetimeOrNull(value: string | number | Date): Date | null {\r\n  if (!value) {\r\n    return null;\r\n  }\r\n  if (typeof value === 'number') {\r\n    return new Date(value);\r\n  }\r\n  if (value instanceof Date && !isNaN(value.valueOf())) {\r\n    return value;\r\n  }\r\n  // only string values can be converted to Date\r\n  if (typeof value !== 'string') {\r\n    return null;\r\n  }\r\n\r\n  const strValue = String(value);\r\n  if (!strValue.length) {\r\n    return null;\r\n  }\r\n\r\n  const parseMonth = (mm: string): number => {\r\n    if (!mm || !mm.length) {\r\n      return NaN;\r\n    }\r\n\r\n    const m = parseInt(mm, 10);\r\n    if (!isNaN(m)) {\r\n      return m - 1;\r\n    }\r\n\r\n    // make sure english months are coming through\r\n    if (mm.startsWith('jan')) {\r\n      return 0;\r\n    }\r\n    if (mm.startsWith('feb')) {\r\n      return 1;\r\n    }\r\n    if (mm.startsWith('mar')) {\r\n      return 2;\r\n    }\r\n    if (mm.startsWith('apr')) {\r\n      return 3;\r\n    }\r\n    if (mm.startsWith('may')) {\r\n      return 4;\r\n    }\r\n    if (mm.startsWith('jun')) {\r\n      return 5;\r\n    }\r\n    if (mm.startsWith('jul')) {\r\n      return 6;\r\n    }\r\n    if (mm.startsWith('aug')) {\r\n      return 7;\r\n    }\r\n    if (mm.startsWith('sep')) {\r\n      return 8;\r\n    }\r\n    if (mm.startsWith('oct')) {\r\n      return 9;\r\n    }\r\n    if (mm.startsWith('nov')) {\r\n      return 10;\r\n    }\r\n    if (mm.startsWith('dec')) {\r\n      return 11;\r\n    }\r\n\r\n    return NaN;\r\n  };\r\n\r\n  const correctYear = (yy: number): number => {\r\n    if (yy < 100) {\r\n      return yy < 68 ? yy + 2000 : yy + 1900;\r\n    } else {\r\n      return yy;\r\n    }\r\n  };\r\n\r\n  const validDateOrNull = (\r\n    yyyy: number,\r\n    month: number,\r\n    day: number,\r\n    hours: number,\r\n    mins: number,\r\n    ss: number\r\n  ): Date | null => {\r\n    if (month > 11 || day > 31 || hours >= 60 || mins >= 60 || ss >= 60) {\r\n      return null;\r\n    }\r\n\r\n    const dd = new Date(yyyy, month, day, hours, mins, ss, 0);\r\n    return !isNaN(dd.valueOf()) ? dd : null;\r\n  };\r\n\r\n  const strTokens = strValue\r\n    .replace('T', ' ')\r\n    .toLowerCase()\r\n    .split(/[: /-]/);\r\n  const dt = strTokens.map(parseFloat);\r\n\r\n  // try ISO first\r\n  let d = validDateOrNull(dt[0], dt[1] - 1, dt[2], dt[3] || 0, dt[4] || 0, dt[5] || 0);\r\n  if (d) {\r\n    return d;\r\n  }\r\n\r\n  // then UK\r\n  d = validDateOrNull(\r\n    correctYear(dt[2]),\r\n    parseMonth(strTokens[1]),\r\n    dt[0],\r\n    dt[3] || 0,\r\n    dt[4] || 0,\r\n    dt[5] || 0\r\n  );\r\n  if (d) {\r\n    return d;\r\n  }\r\n\r\n  // then US\r\n  d = validDateOrNull(\r\n    correctYear(dt[2]),\r\n    parseMonth(strTokens[0]),\r\n    correctYear(dt[1]),\r\n    dt[3] || 0,\r\n    dt[4] || 0,\r\n    dt[5] || 0\r\n  );\r\n  if (d) {\r\n    return d;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport function getImportType(name: string): 'jspyModule' | 'jsPackage' | 'json' {\r\n  if (name.startsWith('/') || name.startsWith('./')) {\r\n    return name.endsWith('.json') ? 'json' : 'jspyModule';\r\n  }\r\n\r\n  return 'jsPackage';\r\n}\r\n\r\nfunction jspyErrorMessage(\r\n  error: string,\r\n  module: string,\r\n  line: number,\r\n  column: number,\r\n  message: string\r\n): string {\r\n  return `${error}: ${module}(${line},${column}): ${message}`;\r\n}\r\n\r\nexport class JspyTokenizerError extends Error {\r\n  constructor(\r\n    public module: string,\r\n    public line: number,\r\n    public column: number,\r\n    public message: string\r\n  ) {\r\n    super();\r\n    this.message = jspyErrorMessage('JspyTokenizerError', module, line, column, message);\r\n    Object.setPrototypeOf(this, JspyTokenizerError.prototype);\r\n  }\r\n}\r\n\r\nexport class JspyParserError extends Error {\r\n  constructor(\r\n    public module: string,\r\n    public line: number,\r\n    public column: number,\r\n    public message: string\r\n  ) {\r\n    super();\r\n    this.message = jspyErrorMessage('JspyParserError', module, line, column, message);\r\n    Object.setPrototypeOf(this, JspyParserError.prototype);\r\n  }\r\n}\r\n\r\nexport class JspyEvalError extends Error {\r\n  constructor(\r\n    public module: string,\r\n    public line: number,\r\n    public column: number,\r\n    public message: string\r\n  ) {\r\n    super();\r\n    this.message = jspyErrorMessage('JspyEvalError', module, line, column, message);\r\n    Object.setPrototypeOf(this, JspyEvalError.prototype);\r\n  }\r\n}\r\n\r\nexport class JspyError extends Error {\r\n  constructor(\r\n    public module: string,\r\n    public line: number,\r\n    public column: number,\r\n    public name: string,\r\n    public message: string\r\n  ) {\r\n    super();\r\n    this.message = jspyErrorMessage('JspyError', module || 'name.jspy', line, column, message);\r\n    Object.setPrototypeOf(this, JspyError.prototype);\r\n  }\r\n}\r\n","export enum OperationTypes {\r\n  Arithmetic,\r\n  Assignment,\r\n  Comparison,\r\n  Logical,\r\n  Membership\r\n}\r\n\r\nexport type AssignmentOperators = '=' | '+=' | '-=' | '*=' | '/=' | '++' | '--';\r\nexport type ArithmeticOperators = '+' | '-' | '*' | '/' | '%' | '**' | '//';\r\nexport type ComparisonOperators = '>' | '>=' | '==' | '!=' | '<>' | '<' | '<=';\r\nexport type LogicalOperators = 'and' | 'or'; // | \"not\" | \"not in\";\r\nexport type MembershipOperators = 'in';\r\n\r\nexport type Operators =\r\n  | AssignmentOperators\r\n  | ArithmeticOperators\r\n  | ComparisonOperators\r\n  | LogicalOperators\r\n  | MembershipOperators;\r\n\r\nexport const OperatorsMap: Record<Operators, OperationTypes> = {\r\n  '+': OperationTypes.Arithmetic,\r\n  '-': OperationTypes.Arithmetic,\r\n  '*': OperationTypes.Arithmetic,\r\n  '/': OperationTypes.Arithmetic,\r\n  '%': OperationTypes.Arithmetic,\r\n  '**': OperationTypes.Arithmetic,\r\n  '//': OperationTypes.Arithmetic,\r\n\r\n  '>': OperationTypes.Comparison,\r\n  '>=': OperationTypes.Comparison,\r\n  '==': OperationTypes.Comparison,\r\n  '!=': OperationTypes.Comparison,\r\n  '<>': OperationTypes.Comparison,\r\n  '<': OperationTypes.Comparison,\r\n  '<=': OperationTypes.Comparison,\r\n\r\n  and: OperationTypes.Logical,\r\n  or: OperationTypes.Logical,\r\n  // \"not\": OperationTypes.Logical,\r\n  // \"not in\": OperationTypes.Logical,\r\n\r\n  in: OperationTypes.Membership,\r\n\r\n  '=': OperationTypes.Assignment,\r\n  '+=': OperationTypes.Assignment,\r\n  '-=': OperationTypes.Assignment,\r\n  '*=': OperationTypes.Assignment,\r\n  '/=': OperationTypes.Assignment,\r\n  '++': OperationTypes.Assignment,\r\n  '--': OperationTypes.Assignment\r\n};\r\n\r\nexport type Primitive = string | number | boolean | null;\r\n\r\nexport type ExpressionOperators =\r\n  | ArithmeticOperators\r\n  | ComparisonOperators\r\n  | LogicalOperators\r\n  | MembershipOperators;\r\ntype ExpressionOperation = (l: Primitive, r: Primitive) => Primitive;\r\n\r\nexport const OperationFuncs: Record<ExpressionOperators, ExpressionOperation> = {\r\n  '+': (l, r) => arithmeticOperation(l, r, '+'),\r\n  '-': (l, r) => arithmeticOperation(l, r, '-'),\r\n  '/': (l, r) => arithmeticOperation(l, r, '/'),\r\n  '*': (l, r) => arithmeticOperation(l, r, '*'),\r\n  '%': (l, r) => arithmeticOperation(l, r, '%'),\r\n  '**': (l, r) => arithmeticOperation(l, r, '**'),\r\n  '//': (l, r) => arithmeticOperation(l, r, '//'),\r\n\r\n  '>': (l, r) => comparissonOperation(l, r, '>'),\r\n  '>=': (l, r) => comparissonOperation(l, r, '>='),\r\n  '<': (l, r) => comparissonOperation(l, r, '<'),\r\n  '<=': (l, r) => comparissonOperation(l, r, '<='),\r\n  '==': (l, r) => comparissonOperation(l, r, '=='),\r\n  '!=': (l, r) => comparissonOperation(l, r, '!='),\r\n  '<>': (l, r) => comparissonOperation(l, r, '<>'),\r\n\r\n  and: (l, r) => logicalOperation(l, r, 'and'),\r\n  or: (l, r) => logicalOperation(l, r, 'or'),\r\n  // \"not\": (l, r) => logicalOperation(l, r, \"not\"),\r\n  // \"not in\": (l, r) => logicalOperation(l, r, \"not in\"),\r\n\r\n  in: (l, r) => membershipOperation(l, r, 'in')\r\n};\r\n\r\nfunction membershipOperation(l: Primitive, r: Primitive, op: MembershipOperators): Primitive {\r\n  if (typeof l === 'string') {\r\n    return (l as string).includes(String(r));\r\n  }\r\n\r\n  if (Array.isArray(l)) {\r\n    return (l as unknown[]).includes(r);\r\n  }\r\n\r\n  throw new Error(`Unknown operation '${op}'`);\r\n}\r\n\r\nfunction logicalOperation(l: Primitive, r: Primitive, op: LogicalOperators): Primitive {\r\n  switch (op) {\r\n    case 'and':\r\n      return l && r;\r\n\r\n    case 'or':\r\n      return l || r;\r\n  }\r\n  throw new Error(`Unknown operation '${op}'`);\r\n}\r\n\r\nfunction comparissonOperation(l: Primitive, r: Primitive, op: ComparisonOperators): Primitive {\r\n  switch (op) {\r\n    case '==':\r\n      return l === r;\r\n\r\n    case '!=':\r\n      return l !== r;\r\n\r\n    case '<>':\r\n      return l !== r;\r\n\r\n    case '>':\r\n      return (l as number) > (r as number);\r\n\r\n    case '<':\r\n      return (l as number) < (r as number);\r\n\r\n    case '>=':\r\n      return (l as number) >= (r as number);\r\n\r\n    case '<=':\r\n      return (l as number) <= (r as number);\r\n  }\r\n\r\n  throw new Error(`Unknown operation '${op}'`);\r\n}\r\n\r\nfunction arithmeticOperation(l: Primitive, r: Primitive, op: ArithmeticOperators): Primitive {\r\n  switch (op) {\r\n    case '+':\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      return (l as any) + (r as any);\r\n\r\n    case '-':\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      return (l as any) - (r as any);\r\n\r\n    case '*':\r\n      return (l as number) * (r as number);\r\n\r\n    case '/':\r\n      return (l as number) / (r as number);\r\n\r\n    case '%':\r\n      return (l as number) % (r as number);\r\n\r\n    case '**':\r\n      return Math.pow(l as number, r as number);\r\n  }\r\n\r\n  throw new Error(`Unknown operation '${op}'`);\r\n}\r\n","import { OperationTypes, Operators, OperatorsMap } from './operators';\r\n\r\nexport enum TokenTypes {\r\n  Identifier = 0,\r\n  Keyword = 1,\r\n  Separator = 2,\r\n  Operator = 3,\r\n  LiteralNumber = 4,\r\n  LiteralBool = 5,\r\n  LiteralString = 6,\r\n  LiteralNull = 7,\r\n  Comment = 8\r\n}\r\n/**\r\n * Token represent a single considered token in a script. Is represented as an array, where element at:\r\n *  0 : value\r\n *  1 : token details. For a memory and performance reasons we use Uint16Array with 5 elements in it:\r\n *    [\r\n *      0 - tokenType number equivalent of @TokenTypes\r\n *      1 - beginLine\r\n *      2 - beginColumn\r\n *      3 - endLine\r\n *      4 - endColumn\r\n *    ]\r\n * [(value). Uint16Array[5]([tokenType, beginLine, beginColumn, endLine, endColumn])]\r\n * tokenType\r\n */\r\nexport type Token = [string | number | boolean | null, Uint16Array];\r\nexport type TokenValue = string | number | boolean | null;\r\n\r\nexport function isTokenTypeLiteral(tokenType: TokenTypes): boolean {\r\n  return (\r\n    tokenType === TokenTypes.LiteralString ||\r\n    tokenType === TokenTypes.LiteralNumber ||\r\n    tokenType === TokenTypes.LiteralBool ||\r\n    tokenType === TokenTypes.LiteralNull\r\n  );\r\n}\r\n\r\nexport function getTokenType(token: Token): TokenTypes {\r\n  return token[1][0] as TokenTypes;\r\n}\r\n\r\nexport function getTokenValue(token: Token | null): TokenValue {\r\n  return token ? token[0] : null;\r\n}\r\n\r\nexport function getTokenLoc(token: Token): Uint16Array {\r\n  return token[1].subarray(1);\r\n}\r\n\r\nexport function getStartLine(token: Token): number {\r\n  return token[1][1];\r\n}\r\n\r\nexport function getStartColumn(token: Token): number {\r\n  return token[1][2];\r\n}\r\n\r\nexport function getEndLine(token: Token): number {\r\n  return token[1][3];\r\n}\r\n\r\nexport function getEndColumn(token: Token): number {\r\n  return token[1][4];\r\n}\r\n\r\nexport function splitTokensByIndexes(tokens: Token[], sepIndexes: number[]): Token[][] {\r\n  const result: Token[][] = [];\r\n\r\n  if (!tokens.length) {\r\n    return [];\r\n  }\r\n\r\n  let start = 0;\r\n  for (let i = 0; i < sepIndexes.length; i++) {\r\n    const ind = sepIndexes[i];\r\n    if (getTokenValue(tokens[start - 1]) === '[') {\r\n      start = start - 1;\r\n    }\r\n    result.push(tokens.slice(start, ind));\r\n    start = ind + 1;\r\n  }\r\n\r\n  if (getTokenValue(tokens[start - 1]) === '[') {\r\n    start = start - 1;\r\n  }\r\n  result.push(tokens.slice(start, tokens.length));\r\n  return result;\r\n}\r\n\r\nexport function splitTokens(tokens: Token[], separator: string): Token[][] {\r\n  if (!tokens.length) {\r\n    return [];\r\n  }\r\n  const sepIndexes = findTokenValueIndexes(tokens, value => value === separator);\r\n  return splitTokensByIndexes(tokens, sepIndexes);\r\n}\r\n\r\nexport function findTokenValueIndex(\r\n  tokens: Token[],\r\n  predicate: (value: TokenValue) => boolean,\r\n  start = 0\r\n): number {\r\n  for (let i = start; i < tokens.length; i++) {\r\n    if (getTokenType(tokens[i]) === TokenTypes.LiteralString) {\r\n      continue;\r\n    }\r\n\r\n    if (getTokenValue(tokens[i]) === '(') {\r\n      i = skipInnerBrackets(tokens, i, '(', ')');\r\n    } else if (getTokenValue(tokens[i]) === '[') {\r\n      i = skipInnerBrackets(tokens, i, '[', ']');\r\n    } else if (getTokenValue(tokens[i]) === '{') {\r\n      i = skipInnerBrackets(tokens, i, '{', '}');\r\n    } else if (predicate(getTokenValue(tokens[i]))) {\r\n      return i;\r\n    }\r\n  }\r\n\r\n  return -1;\r\n}\r\n\r\nexport function findChainingCallTokensIndexes(tokens: Token[]): number[] {\r\n  const opIndexes: number[] = [];\r\n\r\n  for (let i = 0; i < tokens.length; i++) {\r\n    const tValue = getTokenValue(tokens[i]);\r\n    const tType = getTokenType(tokens[i]);\r\n\r\n    if (tType === TokenTypes.LiteralString) {\r\n      continue;\r\n    }\r\n\r\n    if (tValue === '.') {\r\n      opIndexes.push(i);\r\n    } else if (tValue === '(') {\r\n      i = skipInnerBrackets(tokens, i, '(', ')');\r\n    } else if (tValue === '[' && i === 0) {\r\n      i = skipInnerBrackets(tokens, i, '[', ']');\r\n    } else if (tValue === '[' && i !== 0) {\r\n      opIndexes.push(i);\r\n      i = skipInnerBrackets(tokens, i, '[', ']');\r\n    } else if (tValue === '{') {\r\n      i = skipInnerBrackets(tokens, i, '{', '}');\r\n    }\r\n  }\r\n\r\n  return opIndexes;\r\n}\r\n\r\nexport function findTokenValueIndexes(\r\n  tokens: Token[],\r\n  predicate: (value: TokenValue) => boolean\r\n): number[] {\r\n  const opIndexes: number[] = [];\r\n\r\n  for (let i = 0; i < tokens.length; i++) {\r\n    const tValue = getTokenValue(tokens[i]);\r\n    const tType = getTokenType(tokens[i]);\r\n\r\n    if (tType === TokenTypes.LiteralString) {\r\n      continue;\r\n    }\r\n\r\n    if (tValue === '(') {\r\n      i = skipInnerBrackets(tokens, i, '(', ')');\r\n    } else if (tValue === '[') {\r\n      i = skipInnerBrackets(tokens, i, '[', ']');\r\n    } else if (tValue === '{') {\r\n      i = skipInnerBrackets(tokens, i, '{', '}');\r\n    } else if (predicate(tValue)) {\r\n      opIndexes.push(i);\r\n    }\r\n  }\r\n\r\n  return opIndexes;\r\n}\r\n\r\nexport function findOperators(\r\n  tokens: Token[],\r\n  operationType: OperationTypes | null = null\r\n): number[] {\r\n  return !operationType\r\n    ? findTokenValueIndexes(tokens, value => OperatorsMap[value as Operators] !== undefined)\r\n    : findTokenValueIndexes(tokens, value => OperatorsMap[value as Operators] === operationType);\r\n}\r\n\r\nfunction skipInnerBrackets(\r\n  tokens: Token[],\r\n  i: number,\r\n  openChar: string,\r\n  closeChar: string\r\n): number {\r\n  let innerBrackets = 0;\r\n  while (getTokenValue(tokens[++i]) !== closeChar || innerBrackets !== 0) {\r\n    if (i + 1 >= tokens.length) {\r\n      throw new Error(`Closing '${closeChar}' is missing`);\r\n    }\r\n\r\n    const tokenValue = getTokenValue(tokens[i]);\r\n    if (tokenValue === openChar) {\r\n      innerBrackets++;\r\n    }\r\n    if (tokenValue === closeChar) {\r\n      innerBrackets--;\r\n    }\r\n  }\r\n  return i;\r\n}\r\n","import { ExpressionOperators, LogicalOperators } from './operators';\r\nimport { getTokenLoc, getTokenValue, Token } from './token-types';\r\n\r\nexport type AstNodeType =\r\n  | 'assign'\r\n  | 'binOp'\r\n  | 'const'\r\n  | 'logicalOp'\r\n  | 'getSingleVar'\r\n  | 'setSingleVar'\r\n  | 'chainingCalls'\r\n  | 'chainingObjectAccess'\r\n  | 'funcCall'\r\n  | 'funcDef'\r\n  | 'arrowFuncDef'\r\n  | 'createObject'\r\n  | 'createArray'\r\n  | 'if'\r\n  | 'elif'\r\n  | 'for'\r\n  | 'while'\r\n  | 'tryExcept'\r\n  | 'raise'\r\n  | 'import'\r\n  | 'comment'\r\n  | 'return'\r\n  | 'continue'\r\n  | 'break';\r\n\r\nexport interface NameAlias {\r\n  name: string;\r\n  alias: string | undefined;\r\n}\r\n\r\nexport interface ExceptBody {\r\n  error: NameAlias;\r\n  body: AstNode[];\r\n}\r\n\r\nexport interface FuncDefNode {\r\n  params: string[];\r\n  funcAst: AstBlock;\r\n}\r\n\r\nexport interface IsNullCoelsing {\r\n  nullCoelsing: boolean | undefined;\r\n}\r\n\r\nexport interface ObjectPropertyInfo {\r\n  name: AstNode;\r\n  value: AstNode;\r\n}\r\n\r\nexport abstract class AstNode {\r\n  loc: Uint16Array | undefined = undefined;\r\n  constructor(public type: AstNodeType) {}\r\n}\r\n\r\nexport class AssignNode extends AstNode {\r\n  constructor(public target: AstNode, public source: AstNode, public loc: Uint16Array) {\r\n    super('assign');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class ConstNode extends AstNode {\r\n  public value: number | string | boolean | null;\r\n\r\n  constructor(token: Token) {\r\n    super('const');\r\n    this.value = getTokenValue(token);\r\n    this.loc = getTokenLoc(token);\r\n  }\r\n}\r\n\r\nexport class CommentNode extends AstNode {\r\n  constructor(public comment: string, public loc: Uint16Array) {\r\n    super('comment');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class ReturnNode extends AstNode {\r\n  constructor(public returnValue: AstNode | undefined = undefined, public loc: Uint16Array) {\r\n    super('return');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class RaiseNode extends AstNode {\r\n  constructor(public errorName: string, public errorMessageAst: AstNode, public loc: Uint16Array) {\r\n    super('raise');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class ContinueNode extends AstNode {\r\n  constructor() {\r\n    super('continue');\r\n  }\r\n}\r\n\r\nexport class BreakNode extends AstNode {\r\n  constructor() {\r\n    super('break');\r\n  }\r\n}\r\n\r\nexport class SetSingleVarNode extends AstNode {\r\n  public name: string;\r\n  constructor(token: Token) {\r\n    super('setSingleVar');\r\n    this.name = token[0] as string;\r\n    this.loc = getTokenLoc(token);\r\n  }\r\n}\r\n\r\nexport class FunctionCallNode extends AstNode implements IsNullCoelsing {\r\n  public nullCoelsing: boolean | undefined = undefined;\r\n\r\n  constructor(public name: string, public paramNodes: AstNode[] | null, public loc: Uint16Array) {\r\n    super('funcCall');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class FunctionDefNode extends AstNode implements FuncDefNode {\r\n  constructor(\r\n    public funcAst: AstBlock,\r\n    public params: string[],\r\n    public isAsync: boolean,\r\n    public loc: Uint16Array\r\n  ) {\r\n    super('funcDef');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class ArrowFuncDefNode extends AstNode implements FuncDefNode {\r\n  constructor(public funcAst: AstBlock, public params: string[], public loc: Uint16Array) {\r\n    super('arrowFuncDef');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class ElifNode extends AstNode {\r\n  constructor(\r\n    public conditionNode: AstNode,\r\n    public elifBody: AstNode[],\r\n    public loc: Uint16Array\r\n  ) {\r\n    super('elif');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class IfNode extends AstNode {\r\n  constructor(\r\n    public conditionNode: AstNode,\r\n    public ifBody: AstNode[],\r\n    public elifs: ElifNode[] | undefined = undefined,\r\n    public elseBody: AstNode[] | undefined = undefined,\r\n    public loc: Uint16Array,\r\n  ) {\r\n    super('if');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class TryExceptNode extends AstNode {\r\n  constructor(\r\n    public tryBody: AstNode[],\r\n    public exepts: ExceptBody[],\r\n    public elseBody: AstNode[] | undefined,\r\n    public finallyBody: AstNode[] | undefined,\r\n\r\n    public loc: Uint16Array\r\n  ) {\r\n    super('tryExcept');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class ForNode extends AstNode {\r\n  constructor(\r\n    public sourceArray: AstNode,\r\n    public itemVarName: string,\r\n    public body: AstNode[],\r\n    public loc: Uint16Array\r\n  ) {\r\n    super('for');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class WhileNode extends AstNode {\r\n  constructor(public condition: AstNode, public body: AstNode[], public loc: Uint16Array) {\r\n    super('while');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class ImportNode extends AstNode {\r\n  constructor(\r\n    public module: NameAlias,\r\n    public body: AstBlock,\r\n    public parts: NameAlias[] | undefined = undefined,\r\n    public loc: Uint16Array\r\n  ) {\r\n    super('import');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class GetSingleVarNode extends AstNode implements IsNullCoelsing {\r\n  name: string;\r\n  nullCoelsing: boolean | undefined = undefined;\r\n\r\n  constructor(token: Token, nullCoelsing: boolean | undefined = undefined) {\r\n    super('getSingleVar');\r\n    this.name = token[0] as string;\r\n    this.nullCoelsing = nullCoelsing;\r\n    this.loc = getTokenLoc(token);\r\n  }\r\n}\r\n\r\nexport class ChainingCallsNode extends AstNode {\r\n  constructor(public innerNodes: AstNode[], public loc: Uint16Array) {\r\n    super('chainingCalls');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class CreateObjectNode extends AstNode {\r\n  constructor(public props: ObjectPropertyInfo[], public loc: Uint16Array) {\r\n    super('createObject');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class CreateArrayNode extends AstNode {\r\n  constructor(public items: AstNode[], public loc: Uint16Array) {\r\n    super('createArray');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class ChainingObjectAccessNode extends AstNode {\r\n  constructor(\r\n    public indexerBody: AstNode,\r\n    public nullCoelsing: boolean | undefined = undefined,\r\n    public loc: Uint16Array\r\n  ) {\r\n    super('chainingObjectAccess');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport interface LogicalNodeItem {\r\n  node: AstNode;\r\n  op: LogicalOperators | undefined;\r\n}\r\n\r\nexport class LogicalOpNode extends AstNode {\r\n  constructor(public items: LogicalNodeItem[], public loc: Uint16Array) {\r\n    super('logicalOp');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport class BinOpNode extends AstNode {\r\n  constructor(\r\n    public left: AstNode,\r\n    public op: ExpressionOperators,\r\n    public right: AstNode,\r\n    public loc: Uint16Array\r\n  ) {\r\n    super('binOp');\r\n    this.loc = loc;\r\n  }\r\n}\r\n\r\nexport interface AstBlock {\r\n  name: string;\r\n  type: 'module' | 'func' | 'if' | 'for' | 'while' | 'trycatch';\r\n  funcs: FunctionDefNode[];\r\n  body: AstNode[];\r\n}\r\n","export interface CancellationToken {\r\n  cancel?: boolean;\r\n  message?: string;\r\n}\r\n\r\nexport interface BlockContext {\r\n  moduleName: string;\r\n  blockScope: Scope;\r\n  cancellationToken: CancellationToken;\r\n  returnCalled?: boolean;\r\n  breakCalled?: boolean;\r\n  continueCalled?: boolean;\r\n  returnObject?: unknown;\r\n}\r\n\r\nexport function cloneContext(context: BlockContext): BlockContext {\r\n  return {\r\n    moduleName: context.moduleName,\r\n    blockScope: context.blockScope.clone(),\r\n    // this instance should never change. Otherwise cancel won't work\r\n    cancellationToken: context.cancellationToken\r\n  } as BlockContext;\r\n}\r\n\r\nexport class Scope {\r\n  private readonly scope: Record<string, unknown> = {};\r\n\r\n  constructor(initialScope: Record<string, unknown>) {\r\n    this.scope = { ...initialScope };\r\n  }\r\n\r\n  getScope(): Record<string, unknown> {\r\n    return this.scope;\r\n  }\r\n\r\n  clone(): Scope {\r\n    return new Scope(this.scope);\r\n  }\r\n  set(key: string, value: unknown): void {\r\n    this.scope[key] = value;\r\n  }\r\n\r\n  get(key: string): unknown {\r\n    return this.scope[key];\r\n  }\r\n}\r\n","import {\r\n  ArrowFuncDefNode,\r\n  AssignNode,\r\n  AstBlock,\r\n  AstNode,\r\n  BinOpNode,\r\n  ChainingCallsNode,\r\n  ChainingObjectAccessNode,\r\n  ConstNode,\r\n  CreateArrayNode,\r\n  CreateObjectNode,\r\n  ForNode,\r\n  FuncDefNode,\r\n  FunctionCallNode,\r\n  FunctionDefNode,\r\n  GetSingleVarNode,\r\n  IfNode,\r\n  IsNullCoelsing,\r\n  LogicalOpNode,\r\n  OperationFuncs,\r\n  Primitive,\r\n  RaiseNode,\r\n  ReturnNode,\r\n  SetSingleVarNode,\r\n  TryExceptNode,\r\n  WhileNode\r\n} from '../common';\r\nimport { JspyError, JspyEvalError } from '../common/utils';\r\nimport { BlockContext, cloneContext } from './scope';\r\n\r\nexport class Evaluator {\r\n  evalBlock(ast: AstBlock, blockContext: BlockContext): unknown {\r\n    let lastResult = null;\r\n\r\n    for (const node of ast?.funcs || []) {\r\n      const funcDef = node as FunctionDefNode;\r\n\r\n      // a child scope needs to be created here\r\n      const newScope = blockContext.blockScope;\r\n\r\n      newScope.set(funcDef.funcAst.name, (...args: unknown[]): unknown =>\r\n        this.jspyFuncInvoker(funcDef, blockContext, ...args)\r\n      );\r\n    }\r\n\r\n    for (let i = 0; i < ast.body.length; i++) {\r\n      const node = ast.body[i];\r\n      if (blockContext.cancellationToken.cancel) {\r\n        const loc = node.loc || [];\r\n\r\n        if (!blockContext.cancellationToken.message) {\r\n          blockContext.cancellationToken.message = `Cancelled. ${blockContext.moduleName}: ${loc[0]}, ${loc[1]}`;\r\n        }\r\n\r\n        return blockContext.cancellationToken.message;\r\n      }\r\n\r\n      if (node.type === 'comment') {\r\n        continue;\r\n      }\r\n      if (node.type === 'import') {\r\n        // we can't use it here, because loader has to be promise\r\n        throw new Error(`Import is not support with 'eval'. Use method 'evalAsync' instead`);\r\n      }\r\n      try {\r\n        lastResult = this.evalNode(node, blockContext);\r\n\r\n        if (blockContext.returnCalled) {\r\n          const res = blockContext.returnObject;\r\n\r\n          // stop processing return\r\n          if (ast.type == 'func' || ast.type == 'module') {\r\n            blockContext.returnCalled = false;\r\n            blockContext.returnObject = null;\r\n          }\r\n          return res;\r\n        }\r\n\r\n        if (blockContext.continueCalled) {\r\n          break;\r\n        }\r\n        if (blockContext.breakCalled) {\r\n          break;\r\n        }\r\n      } catch (err) {\r\n        const loc = node.loc ? node.loc : [0, 0];\r\n        if (err instanceof JspyError) {\r\n          throw err;\r\n        } else if (err instanceof JspyEvalError) {\r\n          throw err;\r\n        } else {\r\n          throw new JspyEvalError(\r\n            blockContext.moduleName,\r\n            loc[0],\r\n            loc[1],\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            (err as any).message || err\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return lastResult;\r\n  }\r\n\r\n  jspyFuncInvoker(funcDef: FuncDefNode, context: BlockContext, ...args: unknown[]): unknown {\r\n    const ast = Object.assign({}, funcDef.funcAst);\r\n    ast.type = 'func';\r\n\r\n    const blockContext = cloneContext(context);\r\n\r\n    // set parameters into new scope, based incomming arguments\r\n    for (let i = 0; i < funcDef.params?.length || 0; i++) {\r\n      const argValue = args?.length > i ? args[i] : null;\r\n      blockContext.blockScope.set(funcDef.params[i], argValue);\r\n    }\r\n\r\n    return this.evalBlock(ast, blockContext);\r\n  }\r\n\r\n  private invokeFunction(\r\n    func: (...args: unknown[]) => unknown,\r\n    fps: unknown[],\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    loc: { moduleName: string; line: number; column: number }\r\n  ): unknown {\r\n    return func(...fps);\r\n  }\r\n\r\n  private evalNode(node: AstNode, blockContext: BlockContext): unknown {\r\n    if (node.type === 'import') {\r\n      // skip this for now. As modules are implemented externally\r\n      return null;\r\n    }\r\n\r\n    if (node.type === 'comment') {\r\n      return null;\r\n    }\r\n\r\n    if (node.type === 'if') {\r\n      const ifNode = node as IfNode;\r\n      let doElse = true;\r\n      if (this.evalNode(ifNode.conditionNode, blockContext)) {\r\n        this.evalBlock(\r\n          { name: blockContext.moduleName, type: 'if', body: ifNode.ifBody } as AstBlock,\r\n          blockContext\r\n        );\r\n        doElse = false;\r\n      } else if (ifNode.elifs?.length) {\r\n        for (let i = 0; i < ifNode.elifs.length; i++) {\r\n          const elIfNode = ifNode.elifs[i];\r\n\r\n          if (this.evalNode(elIfNode.conditionNode, blockContext)) {\r\n            this.evalBlock(\r\n              { name: blockContext.moduleName, type: 'if', body: elIfNode.elifBody } as AstBlock,\r\n              blockContext\r\n            );\r\n            doElse = false;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      \r\n      if (doElse && ifNode.elseBody) {\r\n        this.evalBlock(\r\n          { name: blockContext.moduleName, type: 'if', body: ifNode.elseBody } as AstBlock,\r\n          blockContext\r\n        );\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'raise') {\r\n      const raiseNode = node as RaiseNode;\r\n      const errorMessage = this.evalNode(raiseNode.errorMessageAst, blockContext) as string;\r\n      const err = new JspyError(\r\n        blockContext.moduleName,\r\n        raiseNode.loc[0],\r\n        raiseNode.loc[1],\r\n        raiseNode.errorName,\r\n        errorMessage\r\n      );\r\n      throw err;\r\n    }\r\n\r\n    if (node.type === 'tryExcept') {\r\n      const tryNode = node as TryExceptNode;\r\n      try {\r\n        this.evalBlock(\r\n          { name: blockContext.moduleName, type: 'trycatch', body: tryNode.tryBody } as AstBlock,\r\n          blockContext\r\n        );\r\n\r\n        if (tryNode.elseBody?.length || 0 > 0) {\r\n          this.evalBlock(\r\n            { name: blockContext.moduleName, type: 'trycatch', body: tryNode.elseBody } as AstBlock,\r\n            blockContext\r\n          );\r\n        }\r\n      } catch (err) {\r\n        const name = err instanceof JspyError ? (err as JspyError).name : typeof err;\r\n        const message =\r\n          err instanceof JspyError\r\n            ? (err as JspyError).message\r\n            : // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n              (err as any)?.message ?? String(err);\r\n        const moduleName = err instanceof JspyError ? (err as JspyError).module : 0;\r\n        const line = err instanceof JspyError ? (err as JspyError).line : 0;\r\n        const column = err instanceof JspyError ? (err as JspyError).column : 0;\r\n\r\n        const firstExept = tryNode.exepts[0];\r\n        const catchBody = firstExept.body;\r\n        const ctx = blockContext; // cloneContext(blockContext);\r\n        ctx.blockScope.set(firstExept.error?.alias || 'error', {\r\n          name,\r\n          message,\r\n          line,\r\n          column,\r\n          moduleName\r\n        });\r\n        this.evalBlock(\r\n          { name: blockContext.moduleName, type: 'trycatch', body: catchBody } as AstBlock,\r\n          ctx\r\n        );\r\n        ctx.blockScope.set(firstExept.error?.alias || 'error', null);\r\n      } finally {\r\n        if (tryNode.finallyBody?.length || 0 > 0) {\r\n          this.evalBlock(\r\n            {\r\n              name: blockContext.moduleName,\r\n              type: 'trycatch',\r\n              body: tryNode.finallyBody\r\n            } as AstBlock,\r\n            blockContext\r\n          );\r\n        }\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'return') {\r\n      const returnNode = node as ReturnNode;\r\n      blockContext.returnCalled = true;\r\n      blockContext.returnObject = returnNode.returnValue\r\n        ? this.evalNode(returnNode.returnValue, blockContext)\r\n        : null;\r\n\r\n      return blockContext.returnObject;\r\n    }\r\n\r\n    if (node.type === 'continue') {\r\n      blockContext.continueCalled = true;\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'break') {\r\n      blockContext.breakCalled = true;\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'for') {\r\n      const forNode = node as ForNode;\r\n\r\n      const array = this.evalNode(forNode.sourceArray, blockContext) as unknown[] | string;\r\n\r\n      for (let i = 0; i < array.length; i++) {\r\n        const item = array[i];\r\n\r\n        blockContext.blockScope.set(forNode.itemVarName, item);\r\n        this.evalBlock(\r\n          { name: blockContext.moduleName, type: 'for', body: forNode.body } as AstBlock,\r\n          blockContext\r\n        );\r\n        if (blockContext.continueCalled) {\r\n          blockContext.continueCalled = false;\r\n        }\r\n        if (blockContext.breakCalled) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (blockContext.breakCalled) {\r\n        blockContext.breakCalled = false;\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'while') {\r\n      const whileNode = node as WhileNode;\r\n\r\n      while (this.evalNode(whileNode.condition, blockContext)) {\r\n        this.evalBlock(\r\n          { name: blockContext.moduleName, type: 'while', body: whileNode.body } as AstBlock,\r\n          blockContext\r\n        );\r\n\r\n        if (blockContext.continueCalled) {\r\n          blockContext.continueCalled = false;\r\n        }\r\n        if (blockContext.breakCalled) {\r\n          break;\r\n        }\r\n      }\r\n      if (blockContext.breakCalled) {\r\n        blockContext.breakCalled = false;\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'const') {\r\n      return (node as ConstNode).value;\r\n    }\r\n\r\n    if (node.type === 'getSingleVar') {\r\n      const name = (node as GetSingleVarNode).name;\r\n\r\n      const value = blockContext.blockScope.get((node as GetSingleVarNode).name);\r\n      if (value === undefined) {\r\n        if (name.charAt(name.length - 1) === ';') {\r\n          throw new Error(`Unexpected ';' in the end.`);\r\n        } else {\r\n          throw new Error(`Variable '${name}' is not defined.`);\r\n        }\r\n      }\r\n      return value;\r\n    }\r\n\r\n    if (node.type === 'binOp') {\r\n      const binOpNode = node as BinOpNode;\r\n      const left = this.evalNode(binOpNode.left, blockContext);\r\n      const right = this.evalNode(binOpNode.right, blockContext);\r\n      return OperationFuncs[binOpNode.op](left as Primitive, right as Primitive);\r\n    }\r\n\r\n    if (node.type === 'logicalOp') {\r\n      const logicalGroups = node as LogicalOpNode;\r\n      let ind = 0;\r\n      let gResult: unknown = true;\r\n\r\n      while (ind < logicalGroups.items.length) {\r\n        const eg = logicalGroups.items[ind++];\r\n\r\n        gResult = this.evalNode(eg.node, blockContext);\r\n\r\n        if (eg.op === 'and' && !gResult) {\r\n          return false;\r\n        }\r\n        if (eg.op === 'or' && gResult) {\r\n          return gResult;\r\n        }\r\n      }\r\n\r\n      return gResult;\r\n    }\r\n\r\n    if (node.type === 'arrowFuncDef') {\r\n      const arrowFuncDef = node as ArrowFuncDefNode;\r\n\r\n      return (...args: unknown[]): unknown =>\r\n        this.jspyFuncInvoker(arrowFuncDef, blockContext, ...args);\r\n    }\r\n\r\n    if (node.type === 'funcCall') {\r\n      const funcCallNode = node as FunctionCallNode;\r\n      const func = blockContext.blockScope.get(funcCallNode.name) as (\r\n        ...args: unknown[]\r\n      ) => unknown;\r\n      if (typeof func !== 'function') {\r\n        throw Error(`'${funcCallNode.name}' is not a function or not defined.`);\r\n      }\r\n\r\n      const pms = funcCallNode.paramNodes?.map(n => this.evalNode(n, blockContext)) || [];\r\n\r\n      return this.invokeFunction(func, pms, {\r\n        moduleName: blockContext.moduleName,\r\n        line: funcCallNode.loc[0],\r\n        column: funcCallNode.loc[1]\r\n      });\r\n    }\r\n\r\n    if (node.type === 'assign') {\r\n      const assignNode = node as AssignNode;\r\n\r\n      if (assignNode.target.type === 'getSingleVar') {\r\n        const node = assignNode.target as SetSingleVarNode;\r\n        blockContext.blockScope.set(node.name, this.evalNode(assignNode.source, blockContext));\r\n      } else if (assignNode.target.type === 'chainingCalls') {\r\n        const targetNode = assignNode.target as ChainingCallsNode;\r\n\r\n        // create a node for all but last property token\r\n        // potentially it can go to parser\r\n        const targetObjectNode = new ChainingCallsNode(\r\n          targetNode.innerNodes.slice(0, targetNode.innerNodes.length - 1),\r\n          targetNode.loc\r\n        );\r\n        const targetObject = this.evalNode(targetObjectNode, blockContext) as Record<\r\n          string,\r\n          unknown\r\n        >;\r\n\r\n        const lastInnerNode = targetNode.innerNodes[targetNode.innerNodes.length - 1];\r\n\r\n        let lastPropertyName = '';\r\n        if (lastInnerNode.type === 'getSingleVar') {\r\n          lastPropertyName = (lastInnerNode as GetSingleVarNode).name;\r\n        } else if (lastInnerNode.type === 'chainingObjectAccess') {\r\n          lastPropertyName = this.evalNode(\r\n            (lastInnerNode as ChainingObjectAccessNode).indexerBody,\r\n            blockContext\r\n          ) as string;\r\n        } else {\r\n          throw Error('Not implemented Assign operation with chaining calls');\r\n        }\r\n\r\n        targetObject[lastPropertyName] = this.evalNode(assignNode.source, blockContext);\r\n      }\r\n\r\n      return null;\r\n    }\r\n\r\n    if (node.type === 'chainingCalls') {\r\n      return this.resolveChainingCallsNode(node as ChainingCallsNode, blockContext);\r\n    }\r\n\r\n    if (node.type === 'createObject') {\r\n      const createObjectNode = node as CreateObjectNode;\r\n      const obj = {} as Record<string, unknown>;\r\n\r\n      for (const p of createObjectNode.props) {\r\n        obj[this.evalNode(p.name, blockContext) as string] = this.evalNode(p.value, blockContext);\r\n      }\r\n\r\n      return obj;\r\n    }\r\n\r\n    if (node.type === 'createArray') {\r\n      const arrayNode = node as CreateArrayNode;\r\n      const res = [] as unknown[];\r\n\r\n      for (const item of arrayNode.items) {\r\n        res.push(this.evalNode(item, blockContext));\r\n      }\r\n\r\n      return res;\r\n    }\r\n  }\r\n\r\n  private resolveChainingCallsNode(chNode: ChainingCallsNode, blockContext: BlockContext): unknown {\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    let startObject = this.evalNode(chNode.innerNodes[0], blockContext) as any;\r\n\r\n    for (let i = 1; i < chNode.innerNodes.length; i++) {\r\n      const nestedProp = chNode.innerNodes[i];\r\n\r\n      if ((chNode.innerNodes[i - 1] as unknown as IsNullCoelsing).nullCoelsing && !startObject) {\r\n        startObject = {};\r\n      }\r\n\r\n      if (nestedProp.type === 'getSingleVar') {\r\n        startObject = startObject[(nestedProp as SetSingleVarNode).name] as unknown;\r\n      } else if (nestedProp.type === 'chainingObjectAccess') {\r\n        const node = nestedProp as ChainingObjectAccessNode;\r\n        // startObject = startObject[node.] as unknown;\r\n        startObject = startObject[\r\n          this.evalNode(node.indexerBody, blockContext) as string\r\n        ] as unknown;\r\n      } else if (nestedProp.type === 'funcCall') {\r\n        const funcCallNode = nestedProp as FunctionCallNode;\r\n        const func = startObject[funcCallNode.name] as (...args: unknown[]) => unknown;\r\n\r\n        if (\r\n          (func === undefined || func === null) &&\r\n          (chNode.innerNodes[i - 1] as unknown as IsNullCoelsing).nullCoelsing\r\n        ) {\r\n          startObject = null;\r\n          continue;\r\n        }\r\n\r\n        if (typeof func !== 'function') {\r\n          throw Error(`'${funcCallNode.name}' is not a function or not defined.`);\r\n        }\r\n        const pms = [];\r\n        for (const p of funcCallNode.paramNodes || []) {\r\n          pms.push(this.evalNode(p, blockContext));\r\n        }\r\n\r\n        startObject = this.invokeFunction(func.bind(startObject), pms, {\r\n          moduleName: blockContext.moduleName,\r\n          line: funcCallNode.loc[0],\r\n          column: funcCallNode.loc[0]\r\n        });\r\n      } else {\r\n        throw Error(\"Can't resolve chainingCalls node\");\r\n      }\r\n    }\r\n\r\n    return startObject === undefined ? null : startObject;\r\n  }\r\n}\r\n","import {\r\n  ArrowFuncDefNode,\r\n  AssignNode,\r\n  AstBlock,\r\n  AstNode,\r\n  BinOpNode,\r\n  ChainingCallsNode,\r\n  ChainingObjectAccessNode,\r\n  ConstNode,\r\n  CreateArrayNode,\r\n  CreateObjectNode,\r\n  ForNode,\r\n  FuncDefNode,\r\n  FunctionCallNode,\r\n  FunctionDefNode,\r\n  GetSingleVarNode,\r\n  IfNode,\r\n  ImportNode,\r\n  IsNullCoelsing,\r\n  LogicalOpNode,\r\n  OperationFuncs,\r\n  Primitive,\r\n  RaiseNode,\r\n  ReturnNode,\r\n  SetSingleVarNode,\r\n  TryExceptNode,\r\n  WhileNode\r\n} from '../common';\r\nimport { JspyEvalError, JspyError, getImportType } from '../common/utils';\r\nimport { Evaluator } from './evaluator';\r\nimport { BlockContext, cloneContext } from './scope';\r\n\r\n/**\r\n * This is copy/paste from Evaluator.\r\n * Sadly, we have to copy code around to support both async and non async methods.\r\n * So, any changes to this method, should be replicated in the evaluator.ts\r\n */\r\nexport class EvaluatorAsync {\r\n  private moduleParser: (modulePath: string) => Promise<AstBlock> = () =>\r\n    Promise.reject('Module parser is not registered!');\r\n  private jsonFileLoader: (jsonFilePath: string) => Promise<string> = () => Promise.reject('{}');\r\n  private blockContextFactory?: (modulePath: string, ast: AstBlock) => BlockContext;\r\n\r\n  registerModuleParser(moduleParser: (modulePath: string) => Promise<AstBlock>): EvaluatorAsync {\r\n    this.moduleParser = moduleParser;\r\n    return this;\r\n  }\r\n\r\n  registerJsonFileLoader(jsonFileLoader: (modulePath: string) => Promise<string>): EvaluatorAsync {\r\n    this.jsonFileLoader = jsonFileLoader;\r\n    return this;\r\n  }\r\n\r\n  registerBlockContextFactory(\r\n    blockContextFactory: (modulePath: string, ast: AstBlock) => BlockContext\r\n  ): EvaluatorAsync {\r\n    this.blockContextFactory = blockContextFactory;\r\n    return this;\r\n  }\r\n\r\n  async evalBlockAsync(ast: AstBlock, blockContext: BlockContext): Promise<unknown> {\r\n    let lastResult = null;\r\n\r\n    for (const node of ast?.funcs || []) {\r\n      const funcDef = node as FunctionDefNode;\r\n\r\n      // a child scope needs to be created here\r\n      const newScope = blockContext.blockScope;\r\n\r\n      const invoker = funcDef.isAsync\r\n        ? async (...args: unknown[]): Promise<unknown> =>\r\n            await this.jspyFuncInvokerAsync(funcDef, blockContext, ...args)\r\n        : (...args: unknown[]): unknown =>\r\n            new Evaluator().jspyFuncInvoker(funcDef, blockContext, ...args);\r\n\r\n      newScope.set(funcDef.funcAst.name, invoker);\r\n    }\r\n\r\n    for (let i = 0; i < ast.body.length; i++) {\r\n      const node = ast.body[i];\r\n      if (blockContext.cancellationToken.cancel) {\r\n        const loc = node.loc || [];\r\n\r\n        if (!blockContext.cancellationToken.message) {\r\n          blockContext.cancellationToken.message = `Cancelled. ${blockContext.moduleName}: ${loc[0]}, ${loc[1]}`;\r\n        }\r\n\r\n        return blockContext.cancellationToken.message;\r\n      }\r\n\r\n      if (node.type === 'comment') {\r\n        continue;\r\n      }\r\n      if (node.type === 'import') {\r\n        const importNode = node as ImportNode;\r\n        const iType = getImportType(importNode.module.name);\r\n\r\n        if (iType === 'json') {\r\n          const jsonValue = JSON.parse(await this.jsonFileLoader(importNode.module.name));\r\n          blockContext.blockScope.set(\r\n            importNode.module.alias || this.defaultModuleName(importNode.module.name),\r\n            jsonValue\r\n          );\r\n          continue;\r\n        } else if (iType !== 'jspyModule') {\r\n          // it is not JSPY import. It is JS and should be handled externally\r\n          continue;\r\n        }\r\n\r\n        if (typeof this.blockContextFactory !== 'function') {\r\n          throw new Error('blockContextFactory is not initialized');\r\n        }\r\n\r\n        const moduleAst = await this.moduleParser(importNode.module.name);\r\n        const moduleBlockContext = this.blockContextFactory(importNode.module.name, moduleAst);\r\n        await this.evalBlockAsync(moduleAst, moduleBlockContext);\r\n\r\n        let scope = blockContext.blockScope.getScope();\r\n\r\n        if (!importNode.parts?.length) {\r\n          // if no parts, then we need to assign to a separate object\r\n          scope = {};\r\n          blockContext.blockScope.set(\r\n            importNode.module.alias || this.defaultModuleName(importNode.module.name),\r\n            scope\r\n          );\r\n        }\r\n\r\n        this.assignFunctionsToScope(\r\n          scope,\r\n          moduleBlockContext,\r\n          moduleAst,\r\n          importNode.parts?.map(p => p.name)\r\n        );\r\n        continue;\r\n      }\r\n\r\n      try {\r\n        lastResult = await this.evalNodeAsync(node, blockContext);\r\n        if (blockContext.returnCalled) {\r\n          const res = blockContext.returnObject;\r\n          // stop processing return\r\n          if (ast.type == 'func' || ast.type == 'module') {\r\n            blockContext.returnCalled = false;\r\n            blockContext.returnObject = null;\r\n          }\r\n          return res;\r\n        }\r\n\r\n        if (blockContext.continueCalled) {\r\n          break;\r\n        }\r\n        if (blockContext.breakCalled) {\r\n          break;\r\n        }\r\n      } catch (err) {\r\n        const loc = node.loc ? node.loc : [0, 0];\r\n        if (err instanceof JspyError) {\r\n          throw err;\r\n        } else if (err instanceof JspyEvalError) {\r\n          throw err;\r\n        } else {\r\n          throw new JspyEvalError(\r\n            blockContext.moduleName,\r\n            loc[0],\r\n            loc[1],\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            (err as any).message || err\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return lastResult;\r\n  }\r\n\r\n  private assignFunctionsToScope(\r\n    scope: Record<string, unknown>,\r\n    moduleBlockContext: BlockContext,\r\n    moduleAst: AstBlock,\r\n    parts?: string[]\r\n  ): void {\r\n    const funcs = moduleAst.funcs.filter(f => !parts || parts.indexOf(f.funcAst?.name) >= 0);\r\n\r\n    for (let i = 0; i < funcs.length; i++) {\r\n      const funcDef = funcs[i] as FunctionDefNode;\r\n\r\n      const invoker = funcDef.isAsync\r\n        ? async (...args: unknown[]): Promise<unknown> =>\r\n            await this.jspyFuncInvokerAsync(funcDef, moduleBlockContext, ...args)\r\n        : (...args: unknown[]): unknown =>\r\n            new Evaluator().jspyFuncInvoker(funcDef, moduleBlockContext, ...args);\r\n\r\n      scope[funcDef.funcAst.name] = invoker;\r\n    }\r\n  }\r\n\r\n  private defaultModuleName(name: string): string {\r\n    return name.substring(name.lastIndexOf('/') + 1, name.lastIndexOf('.'));\r\n  }\r\n\r\n  private async jspyFuncInvokerAsync(\r\n    funcDef: FuncDefNode,\r\n    context: BlockContext,\r\n    ...args: unknown[]\r\n  ): Promise<unknown> {\r\n    const ast = Object.assign({}, funcDef.funcAst);\r\n    ast.type = 'func';\r\n\r\n    const blockContext = cloneContext(context);\r\n\r\n    // set parameters into new scope, based incomming arguments\r\n    for (let i = 0; i < funcDef.params?.length || 0; i++) {\r\n      const argValue = args?.length > i ? args[i] : null;\r\n      blockContext.blockScope.set(funcDef.params[i], argValue);\r\n    }\r\n\r\n    return await this.evalBlockAsync(ast, blockContext);\r\n  }\r\n\r\n  private async invokeFunctionAsync(\r\n    func: (...args: unknown[]) => unknown,\r\n    fps: unknown[],\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    loc?: { moduleName: string; line: number; column: number }\r\n  ): Promise<unknown> {\r\n    return await func(...fps);\r\n  }\r\n\r\n  private async evalNodeAsync(node: AstNode, blockContext: BlockContext): Promise<unknown> {\r\n    if (node.type === 'import') {\r\n      throw new Error('Import should be defined at the start');\r\n    }\r\n\r\n    if (node.type === 'comment') {\r\n      return null;\r\n    }\r\n\r\n    if (node.type === 'if') {\r\n      const ifNode = node as IfNode;\r\n      let doElse = true;\r\n\r\n      if (await this.evalNodeAsync(ifNode.conditionNode, blockContext)) {\r\n        await this.evalBlockAsync(\r\n          { name: blockContext.moduleName, type: 'if', body: ifNode.ifBody } as AstBlock,\r\n          blockContext\r\n        );\r\n        doElse = false;\r\n      } else if (ifNode.elifs?.length) {\r\n        for (let i = 0; i < ifNode.elifs.length; i++) {\r\n          const elIfNode = ifNode.elifs[i];\r\n\r\n          if (await this.evalNodeAsync(elIfNode.conditionNode, blockContext)) {\r\n            await this.evalBlockAsync(\r\n              { name: blockContext.moduleName, type: 'if', body: elIfNode.elifBody } as AstBlock,\r\n              blockContext\r\n            );\r\n            doElse = false;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (doElse && ifNode.elseBody) {\r\n        await this.evalBlockAsync(\r\n          { name: blockContext.moduleName, type: 'if', body: ifNode.elseBody } as AstBlock,\r\n          blockContext\r\n        );\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'raise') {\r\n      const raiseNode = node as RaiseNode;\r\n      const errorMessage = (await this.evalNodeAsync(\r\n        raiseNode.errorMessageAst,\r\n        blockContext\r\n      )) as string;\r\n      const err = new JspyError(\r\n        blockContext.moduleName,\r\n        raiseNode.loc[0],\r\n        raiseNode.loc[1],\r\n        raiseNode.errorName,\r\n        errorMessage\r\n      );\r\n      throw err;\r\n    }\r\n\r\n    if (node.type === 'tryExcept') {\r\n      const tryNode = node as TryExceptNode;\r\n      try {\r\n        await this.evalBlockAsync(\r\n          { name: blockContext.moduleName, type: 'trycatch', body: tryNode.tryBody } as AstBlock,\r\n          blockContext\r\n        );\r\n\r\n        if (tryNode.elseBody?.length || 0 > 0) {\r\n          await this.evalBlockAsync(\r\n            { name: blockContext.moduleName, type: 'trycatch', body: tryNode.elseBody } as AstBlock,\r\n            blockContext\r\n          );\r\n        }\r\n      } catch (err) {\r\n        // catches here all exceptions. Including JSPY Eval errors\r\n        const name = err instanceof JspyError ? (err as JspyError).name : typeof err;\r\n        const message =\r\n          err instanceof JspyError\r\n            ? (err as JspyError).message\r\n            : // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n              (err as any)?.message ?? String(err);\r\n        const moduleName = err instanceof JspyError ? (err as JspyError).module : 0;\r\n        const line = err instanceof JspyError ? (err as JspyError).line : 0;\r\n        const column = err instanceof JspyError ? (err as JspyError).column : 0;\r\n\r\n        const firstExept = tryNode.exepts[0];\r\n        const catchBody = firstExept.body;\r\n        const ctx = blockContext;\r\n        ctx.blockScope.set(firstExept.error?.alias || 'error', {\r\n          name,\r\n          message,\r\n          line,\r\n          column,\r\n          moduleName\r\n        });\r\n        await this.evalBlockAsync(\r\n          { name: blockContext.moduleName, type: 'trycatch', body: catchBody } as AstBlock,\r\n          ctx\r\n        );\r\n        ctx.blockScope.set(firstExept.error?.alias || 'error', null);\r\n      } finally {\r\n        if (tryNode.finallyBody?.length || 0 > 0) {\r\n          await this.evalBlockAsync(\r\n            {\r\n              name: blockContext.moduleName,\r\n              type: 'trycatch',\r\n              body: tryNode.finallyBody\r\n            } as AstBlock,\r\n            blockContext\r\n          );\r\n        }\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'return') {\r\n      const returnNode = node as ReturnNode;\r\n      blockContext.returnCalled = true;\r\n      blockContext.returnObject = returnNode.returnValue\r\n        ? await this.evalNodeAsync(returnNode.returnValue, blockContext)\r\n        : null;\r\n\r\n      return blockContext.returnObject;\r\n    }\r\n\r\n    if (node.type === 'continue') {\r\n      blockContext.continueCalled = true;\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'break') {\r\n      blockContext.breakCalled = true;\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'for') {\r\n      const forNode = node as ForNode;\r\n\r\n      const array = (await this.evalNodeAsync(forNode.sourceArray, blockContext)) as\r\n        | unknown[]\r\n        | string;\r\n      for (let i = 0; i < array.length; i++) {\r\n        const item = array[i];\r\n        blockContext.blockScope.set(forNode.itemVarName, item);\r\n        await this.evalBlockAsync(\r\n          { name: blockContext.moduleName, type: 'for', body: forNode.body } as AstBlock,\r\n          blockContext\r\n        );\r\n        if (blockContext.continueCalled) {\r\n          blockContext.continueCalled = false;\r\n        }\r\n        if (blockContext.breakCalled) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (blockContext.breakCalled) {\r\n        blockContext.breakCalled = false;\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'while') {\r\n      const whileNode = node as WhileNode;\r\n\r\n      while (await this.evalNodeAsync(whileNode.condition, blockContext)) {\r\n        await this.evalBlockAsync(\r\n          { name: blockContext.moduleName, type: 'while', body: whileNode.body } as AstBlock,\r\n          blockContext\r\n        );\r\n\r\n        if (blockContext.continueCalled) {\r\n          blockContext.continueCalled = false;\r\n        }\r\n        if (blockContext.breakCalled) {\r\n          break;\r\n        }\r\n      }\r\n      if (blockContext.breakCalled) {\r\n        blockContext.breakCalled = false;\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (node.type === 'const') {\r\n      return (node as ConstNode).value;\r\n    }\r\n\r\n    if (node.type === 'getSingleVar') {\r\n      const name = (node as GetSingleVarNode).name;\r\n      const value = blockContext.blockScope.get(name);\r\n\r\n      if (value === undefined) {\r\n        if (name.charAt(name.length - 1) === ';') {\r\n          throw new Error(`Unexpected ';' in the end.`);\r\n        } else {\r\n          throw new Error(`Variable '${name}' is not defined.`);\r\n        }\r\n      }\r\n      return value;\r\n    }\r\n\r\n    if (node.type === 'binOp') {\r\n      const binOpNode = node as BinOpNode;\r\n      const left = await this.evalNodeAsync(binOpNode.left, blockContext);\r\n      const right = await this.evalNodeAsync(binOpNode.right, blockContext);\r\n      return OperationFuncs[binOpNode.op](left as Primitive, right as Primitive);\r\n    }\r\n\r\n    if (node.type === 'logicalOp') {\r\n      const logicalGroups = node as LogicalOpNode;\r\n      let ind = 0;\r\n      let gResult: unknown = true;\r\n\r\n      while (ind < logicalGroups.items.length) {\r\n        const eg = logicalGroups.items[ind++];\r\n\r\n        gResult = await this.evalNodeAsync(eg.node, blockContext);\r\n\r\n        if (eg.op === 'and' && !gResult) {\r\n          return false;\r\n        }\r\n        if (eg.op === 'or' && gResult) {\r\n          return gResult;\r\n        }\r\n      }\r\n\r\n      return gResult;\r\n    }\r\n\r\n    if (node.type === 'arrowFuncDef') {\r\n      const arrowFuncDef = node as ArrowFuncDefNode;\r\n\r\n      return (...args: unknown[]): unknown =>\r\n        new Evaluator().jspyFuncInvoker(arrowFuncDef, blockContext, ...args);\r\n    }\r\n\r\n    if (node.type === 'funcCall') {\r\n      const funcCallNode = node as FunctionCallNode;\r\n      const func = blockContext.blockScope.get(funcCallNode.name) as (\r\n        ...args: unknown[]\r\n      ) => unknown;\r\n\r\n      if (typeof func !== 'function') {\r\n        throw Error(`'${funcCallNode.name}' is not a function or not defined.`);\r\n      }\r\n\r\n      const pms = [];\r\n      for (const p of funcCallNode.paramNodes || []) {\r\n        pms.push(await this.evalNodeAsync(p, blockContext));\r\n      }\r\n\r\n      return await this.invokeFunctionAsync(func, pms, {\r\n        moduleName: blockContext.moduleName,\r\n        line: funcCallNode.loc[0],\r\n        column: funcCallNode.loc[0]\r\n      });\r\n    }\r\n\r\n    if (node.type === 'assign') {\r\n      const assignNode = node as AssignNode;\r\n\r\n      if (assignNode.target.type === 'getSingleVar') {\r\n        const node = assignNode.target as SetSingleVarNode;\r\n        blockContext.blockScope.set(\r\n          node.name,\r\n          await this.evalNodeAsync(assignNode.source, blockContext)\r\n        );\r\n      } else if (assignNode.target.type === 'chainingCalls') {\r\n        const targetNode = assignNode.target as ChainingCallsNode;\r\n\r\n        // create a node for all but last property token\r\n        // potentially it can go to parser\r\n        const targetObjectNode = new ChainingCallsNode(\r\n          targetNode.innerNodes.slice(0, targetNode.innerNodes.length - 1),\r\n          targetNode.loc\r\n        );\r\n        const targetObject = (await this.evalNodeAsync(targetObjectNode, blockContext)) as Record<\r\n          string,\r\n          unknown\r\n        >;\r\n\r\n        const lastInnerNode = targetNode.innerNodes[targetNode.innerNodes.length - 1];\r\n\r\n        let lastPropertyName = '';\r\n        if (lastInnerNode.type === 'getSingleVar') {\r\n          lastPropertyName = (lastInnerNode as GetSingleVarNode).name;\r\n        } else if (lastInnerNode.type === 'chainingObjectAccess') {\r\n          lastPropertyName = (await this.evalNodeAsync(\r\n            (lastInnerNode as ChainingObjectAccessNode).indexerBody,\r\n            blockContext\r\n          )) as string;\r\n        } else {\r\n          throw Error('Not implemented Assign operation with chaining calls');\r\n        }\r\n\r\n        targetObject[lastPropertyName] = await this.evalNodeAsync(assignNode.source, blockContext);\r\n      }\r\n\r\n      return null;\r\n    }\r\n\r\n    if (node.type === 'chainingCalls') {\r\n      return await this.resolveChainingCallsNode(node as ChainingCallsNode, blockContext);\r\n    }\r\n\r\n    if (node.type === 'createObject') {\r\n      const createObjectNode = node as CreateObjectNode;\r\n      const obj = {} as Record<string, unknown>;\r\n\r\n      for (const p of createObjectNode.props) {\r\n        obj[(await this.evalNodeAsync(p.name, blockContext)) as string] = await this.evalNodeAsync(\r\n          p.value,\r\n          blockContext\r\n        );\r\n      }\r\n\r\n      return obj;\r\n    }\r\n\r\n    if (node.type === 'createArray') {\r\n      const arrayNode = node as CreateArrayNode;\r\n      const res = [] as unknown[];\r\n\r\n      for (const item of arrayNode.items) {\r\n        res.push(await this.evalNodeAsync(item, blockContext));\r\n      }\r\n\r\n      return res;\r\n    }\r\n  }\r\n\r\n  private async resolveChainingCallsNode(\r\n    chNode: ChainingCallsNode,\r\n    blockContext: BlockContext\r\n  ): Promise<unknown> {\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    let startObject = (await this.evalNodeAsync(chNode.innerNodes[0], blockContext)) as any;\r\n\r\n    for (let i = 1; i < chNode.innerNodes.length; i++) {\r\n      const nestedProp = chNode.innerNodes[i];\r\n\r\n      if ((chNode.innerNodes[i - 1] as unknown as IsNullCoelsing).nullCoelsing && !startObject) {\r\n        startObject = {};\r\n      }\r\n\r\n      if (nestedProp.type === 'getSingleVar') {\r\n        startObject = startObject[(nestedProp as SetSingleVarNode).name] as unknown;\r\n      } else if (nestedProp.type === 'chainingObjectAccess') {\r\n        const node = nestedProp as ChainingObjectAccessNode;\r\n        // startObject = startObject[node.] as unknown;\r\n        startObject = startObject[\r\n          (await this.evalNodeAsync(node.indexerBody, blockContext)) as string\r\n        ] as unknown;\r\n      } else if (nestedProp.type === 'funcCall') {\r\n        const funcCallNode = nestedProp as FunctionCallNode;\r\n        const func = startObject[funcCallNode.name] as (...args: unknown[]) => unknown;\r\n\r\n        if (\r\n          (func === undefined || func === null) &&\r\n          (chNode.innerNodes[i - 1] as unknown as IsNullCoelsing).nullCoelsing\r\n        ) {\r\n          startObject = null;\r\n          continue;\r\n        }\r\n\r\n        if (typeof func !== 'function') {\r\n          throw Error(`'${funcCallNode.name}' is not a function or not defined.`);\r\n        }\r\n        const pms = [];\r\n        for (const p of funcCallNode.paramNodes || []) {\r\n          pms.push(await this.evalNodeAsync(p, blockContext));\r\n        }\r\n\r\n        startObject = await this.invokeFunctionAsync(func.bind(startObject), pms, {\r\n          moduleName: blockContext.moduleName,\r\n          line: funcCallNode.loc[0],\r\n          column: funcCallNode.loc[0]\r\n        });\r\n      } else {\r\n        throw Error(\"Can't resolve chainingCalls node\");\r\n      }\r\n    }\r\n\r\n    return startObject === undefined ? null : startObject;\r\n  }\r\n}\r\n","import { parseDatetimeOrNull } from './common/utils';\r\n\r\nexport const INITIAL_SCOPE = {\r\n  jsPython(): string {\r\n    return `JSPython v2.1.10 (c) 2022 FalconSoft Ltd. All rights reserved.`;\r\n  },\r\n  dateTime: (str: number | string | unknown = null): Date =>\r\n    parseDatetimeOrNull(str as string) || new Date(),\r\n  range: range,\r\n  print: (...args: unknown[]): unknown => {\r\n    console.log(...args);\r\n    return args.length > 0 ? args[0] : null;\r\n  },\r\n  isNull: (v: unknown, defValue: unknown = null): boolean | unknown =>\r\n    defValue === null ? v === null : v || defValue,\r\n  isDate: (d: unknown): boolean => d instanceof Date,\r\n  isFunction: (v: unknown): boolean => typeof v === 'function',\r\n  isString: (v: unknown): boolean => typeof v === 'string',\r\n  deleteProperty: (obj: Record<string, unknown>, propName: string): boolean => delete obj[propName],\r\n  Math: Math,\r\n  Object: Object,\r\n  Array: Array,\r\n  JSON: JSON,\r\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n  printExecutionContext: (): void => {}, // will be overriden at runtime\r\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n  getExecutionContext: (): Record<string, unknown> => ({}) // will be overriden at runtime\r\n};\r\n\r\n/**\r\n * This interface needs to be replaced\r\n */\r\nexport interface PackageToImport {\r\n  name: string;\r\n  properties?: { name: string; as?: string }[];\r\n  as?: string;\r\n}\r\n\r\nfunction range(start: number, stop = NaN, step = 1): number[] {\r\n  const arr: number[] = [];\r\n  const isStopNaN = isNaN(stop);\r\n  stop = isStopNaN ? start : stop;\r\n  start = isStopNaN ? 0 : start;\r\n  let i = start;\r\n  while (i < stop) {\r\n    arr.push(i);\r\n    i += step;\r\n  }\r\n  return arr;\r\n}\r\n","import {\r\n  BinOpNode,\r\n  ConstNode,\r\n  AstBlock,\r\n  Token,\r\n  AstNode,\r\n  Operators,\r\n  AssignNode,\r\n  TokenTypes,\r\n  GetSingleVarNode,\r\n  FunctionCallNode,\r\n  getTokenType,\r\n  getTokenValue,\r\n  isTokenTypeLiteral,\r\n  getStartLine,\r\n  getStartColumn,\r\n  getEndColumn,\r\n  getEndLine,\r\n  findOperators,\r\n  splitTokens,\r\n  findTokenValueIndex,\r\n  FunctionDefNode,\r\n  CreateObjectNode,\r\n  ObjectPropertyInfo,\r\n  CreateArrayNode,\r\n  ArrowFuncDefNode,\r\n  ExpressionOperators,\r\n  IfNode,\r\n  ForNode,\r\n  WhileNode,\r\n  ImportNode,\r\n  NameAlias,\r\n  ContinueNode,\r\n  BreakNode,\r\n  ReturnNode,\r\n  CommentNode,\r\n  getTokenLoc,\r\n  OperationTypes,\r\n  LogicalNodeItem,\r\n  LogicalOperators,\r\n  LogicalOpNode,\r\n  ComparisonOperators,\r\n  TryExceptNode,\r\n  ExceptBody,\r\n  RaiseNode,\r\n  findChainingCallTokensIndexes,\r\n  splitTokensByIndexes,\r\n  ChainingCallsNode,\r\n  ChainingObjectAccessNode,\r\n  ElifNode\r\n} from '../common';\r\nimport { JspyParserError } from '../common/utils';\r\n\r\nclass InstructionLine {\r\n  readonly tokens: Token[] = [];\r\n\r\n  startLine(): number {\r\n    return getStartLine(this.tokens[0]);\r\n  }\r\n\r\n  startColumn(): number {\r\n    return getStartColumn(this.tokens[0]);\r\n  }\r\n\r\n  endLine(): number {\r\n    return getEndLine(this.tokens[this.tokens.length - 1]);\r\n  }\r\n\r\n  endColumn(): number {\r\n    return getEndColumn(this.tokens[this.tokens.length - 1]);\r\n  }\r\n}\r\n\r\nexport class Parser {\r\n  private _currentToken: Token | null = null;\r\n  private _moduleName = '';\r\n\r\n  /**\r\n   * Parses tokens and return Ast - Abstract Syntax Tree for jsPython code\r\n   * @param tokens tokens\r\n   * @param options parsing options. By default it will exclude comments and include LOC (Line of code)\r\n   */\r\n  parse(tokens: Token[], name = 'main.jspy', type = 'module'): AstBlock {\r\n    this._moduleName = name;\r\n    const ast = { name, type, funcs: [], body: [] } as AstBlock;\r\n\r\n    if (!tokens || !tokens.length) {\r\n      return ast;\r\n    }\r\n\r\n    try {\r\n      // group all tokens into an Instruction lines.\r\n      const instructions = this.tokensToInstructionLines(tokens, 1);\r\n\r\n      // process all instructions\r\n      this.instructionsToNodes(instructions, ast);\r\n    } catch (error) {\r\n      const err = error as Error;\r\n      const token = this._currentToken ?? ({} as Token);\r\n      throw new JspyParserError(\r\n        ast.name,\r\n        getStartLine(token),\r\n        getStartColumn(token),\r\n        err.message || String(err)\r\n      );\r\n    }\r\n    return ast;\r\n  }\r\n\r\n  private instructionsToNodes(instructions: InstructionLine[], ast: AstBlock): void {\r\n    const getBody = (tokens: Token[], startTokenIndex: number): AstNode[] => {\r\n      const instructionLines = this.tokensToInstructionLines(\r\n        tokens,\r\n        getStartLine(tokens[startTokenIndex])\r\n      );\r\n      const bodyAst = { name: ast.name, body: [] as AstNode[], funcs: [] as AstNode[] } as AstBlock;\r\n      this.instructionsToNodes(instructionLines, bodyAst);\r\n      return bodyAst.body;\r\n    };\r\n\r\n    const findIndexes = (tkns: Token[], operation: OperationTypes, result: number[]): boolean => {\r\n      result.splice(0, result.length);\r\n      findOperators(tkns, operation).forEach(r => result.push(r));\r\n      return !!result.length;\r\n    };\r\n\r\n    for (let i = 0; i < instructions.length; i++) {\r\n      const instruction = instructions[i];\r\n\r\n      // remove comments\r\n      let tt = 0;\r\n      while (tt < instruction.tokens.length) {\r\n        if (getTokenType(instruction.tokens[tt]) === TokenTypes.Comment) {\r\n          instruction.tokens.splice(tt, 1);\r\n        } else {\r\n          tt++;\r\n        }\r\n      }\r\n      if (!instruction.tokens.length) {\r\n        continue;\r\n      }\r\n\r\n      const firstToken = instruction.tokens[0];\r\n      const secondToken = instruction.tokens.length > 1 ? instruction.tokens[1] : null;\r\n      this._currentToken = firstToken;\r\n\r\n      const logicOpIndexes: number[] = [];\r\n      const assignTokenIndexes: number[] = [];\r\n\r\n      if (getTokenType(firstToken) === TokenTypes.Comment) {\r\n        ast.body.push(\r\n          new CommentNode(getTokenValue(firstToken) as string, getTokenLoc(firstToken))\r\n        );\r\n      } else if (\r\n        getTokenValue(firstToken) === 'def' ||\r\n        (getTokenValue(firstToken) === 'async' && getTokenValue(secondToken) === 'def')\r\n      ) {\r\n        const isAsync = getTokenValue(firstToken) === 'async';\r\n        const funcName = getTokenValue(instruction.tokens[isAsync ? 2 : 1]) as string;\r\n        const paramsTokens = instruction.tokens.slice(\r\n          instruction.tokens.findIndex(tkns => getTokenValue(tkns) === '(') + 1,\r\n          instruction.tokens.findIndex(tkns => getTokenValue(tkns) === ')')\r\n        );\r\n\r\n        const params = splitTokens(paramsTokens, ',').map(t => getTokenValue(t[0]) as string);\r\n\r\n        const endDefOfDef = findTokenValueIndex(instruction.tokens, v => v === ':');\r\n\r\n        if (endDefOfDef === -1) {\r\n          throw `Can't find : for def`;\r\n        }\r\n\r\n        const instructionLines = this.tokensToInstructionLines(\r\n          instruction.tokens,\r\n          getStartLine(instruction.tokens[endDefOfDef + 1])\r\n        );\r\n        const funcAst = {\r\n          name: funcName,\r\n          body: [] as AstNode[],\r\n          funcs: [] as AstNode[]\r\n        } as AstBlock;\r\n        this.instructionsToNodes(instructionLines, funcAst);\r\n\r\n        ast.funcs.push(\r\n          new FunctionDefNode(funcAst, params, isAsync, getTokenLoc(instruction.tokens[0]))\r\n        );\r\n      } else if (getTokenValue(firstToken) === 'if') {\r\n        const endDefOfDef = findTokenValueIndex(instruction.tokens, v => v === ':');\r\n\r\n        if (endDefOfDef === -1) {\r\n          throw `Can't find : for if`;\r\n        }\r\n\r\n        const ifBody = getBody(instruction.tokens, endDefOfDef + 1);\r\n        const conditionTokens = instruction.tokens.slice(1, endDefOfDef);\r\n\r\n        const conditionNode = findIndexes(conditionTokens, OperationTypes.Logical, logicOpIndexes)\r\n          ? this.groupLogicalOperations(logicOpIndexes, conditionTokens)\r\n          : this.createExpressionNode(conditionTokens);\r\n\r\n        // elifs\r\n        const elifNodes: ElifNode[] = [];\r\n        while (\r\n          instructions.length > i + 1 &&\r\n          getTokenValue(instructions[i + 1].tokens[0]) === 'elif'\r\n        ) {\r\n\r\n          const elifInstruction = instructions[++i];\r\n\r\n          const endOfElif = findTokenValueIndex(elifInstruction.tokens, v => v === ':');\r\n\r\n          const conditionTokens = elifInstruction.tokens.slice(1, endDefOfDef);\r\n\r\n          const elifConditionNode = findIndexes(conditionTokens, OperationTypes.Logical, logicOpIndexes)\r\n            ? this.groupLogicalOperations(logicOpIndexes, conditionTokens)\r\n            : this.createExpressionNode(conditionTokens);\r\n  \r\n          const elifBody = getBody(elifInstruction.tokens, endOfElif+1);\r\n          elifNodes.push(\r\n            new ElifNode(elifConditionNode, elifBody, getTokenLoc(elifInstruction.tokens[0]))\r\n          );\r\n          \r\n        }\r\n\r\n        // else\r\n        let elseBody: AstNode[] | undefined = undefined;\r\n        if (\r\n          instructions.length > i + 1 &&\r\n          getTokenValue(instructions[i + 1].tokens[0]) === 'else' &&\r\n          getTokenValue(instructions[i + 1].tokens[1]) === ':'\r\n        ) {\r\n          elseBody = getBody(instructions[i + 1].tokens, 2);\r\n          i++;\r\n        }\r\n\r\n        ast.body.push(\r\n          new IfNode(conditionNode, ifBody, elifNodes, elseBody, getTokenLoc(firstToken))\r\n        );\r\n      } else if (getTokenValue(firstToken) === 'try') {\r\n        if (getTokenValue(instruction.tokens[1]) !== ':') {\r\n          throw `'try' statement should be followed by ':'`;\r\n        }\r\n\r\n        const tryBody = getBody(instruction.tokens, 2);\r\n        const excepts: ExceptBody[] = [];\r\n\r\n        let elseBody: AstNode[] | undefined = undefined;\r\n        let finallyBody: AstNode[] | undefined = undefined;\r\n\r\n        while (\r\n          instructions.length > i + 1 &&\r\n          (getTokenValue(instructions[i + 1].tokens[0]) === 'else' ||\r\n            getTokenValue(instructions[i + 1].tokens[0]) === 'except' ||\r\n            getTokenValue(instructions[i + 1].tokens[0]) === 'finally')\r\n        ) {\r\n          if (getTokenValue(instructions[i + 1].tokens[0]) === 'else') {\r\n            if (elseBody) {\r\n              throw new Error(`Only one 'else' is allowed in a 'try'`);\r\n            }\r\n\r\n            elseBody = getBody(instructions[i + 1].tokens, 2);\r\n          }\r\n\r\n          if (getTokenValue(instructions[i + 1].tokens[0]) === 'finally') {\r\n            if (finallyBody) {\r\n              throw new Error(`Only one 'else' is allowed in a 'try'`);\r\n            }\r\n\r\n            finallyBody = getBody(instructions[i + 1].tokens, 2);\r\n          }\r\n\r\n          if (getTokenValue(instructions[i + 1].tokens[0]) === 'except') {\r\n            const endIndex = findTokenValueIndex(instructions[i + 1].tokens, v => v === ':');\r\n            const except = {} as ExceptBody;\r\n\r\n            if (endIndex === 2) {\r\n              except.error = { name: getTokenValue(instructions[i + 1].tokens[1]) } as NameAlias;\r\n            } else if (endIndex === 3) {\r\n              except.error = {\r\n                name: getTokenValue(instructions[i + 1].tokens[1]),\r\n                alias: getTokenValue(instructions[i + 1].tokens[2])\r\n              } as NameAlias;\r\n            } else if (endIndex === 4) {\r\n              except.error = {\r\n                name: getTokenValue(instructions[i + 1].tokens[1]),\r\n                alias: getTokenValue(instructions[i + 1].tokens[3])\r\n              } as NameAlias;\r\n            } else if (endIndex !== 1) {\r\n              throw new Error(\r\n                `Incorrect 'except:' statement. Valid stats: (except: or except Error: or except Error as e:)`\r\n              );\r\n            }\r\n\r\n            except.body = getBody(instructions[i + 1].tokens, endIndex + 1);\r\n\r\n            excepts.push(except);\r\n          }\r\n\r\n          i++;\r\n        }\r\n\r\n        if (!excepts.length) {\r\n          throw new Error('Except: is missing');\r\n        }\r\n\r\n        ast.body.push(\r\n          new TryExceptNode(tryBody, excepts, elseBody, finallyBody, getTokenLoc(firstToken))\r\n        );\r\n      } else if (getTokenValue(firstToken) === 'continue') {\r\n        ast.body.push(new ContinueNode());\r\n      } else if (getTokenValue(firstToken) === 'break') {\r\n        ast.body.push(new BreakNode());\r\n      } else if (getTokenValue(firstToken) === 'return') {\r\n        ast.body.push(\r\n          new ReturnNode(\r\n            instruction.tokens.length > 1\r\n              ? this.createExpressionNode(instruction.tokens.slice(1))\r\n              : undefined,\r\n            getTokenLoc(firstToken)\r\n          )\r\n        );\r\n      } else if (getTokenValue(firstToken) === 'raise') {\r\n        if (instruction.tokens.length === 1) {\r\n          throw new Error(`Incorrect 'raise' usage. Please specify error name and message `);\r\n        }\r\n        const errorName = getTokenValue(instruction.tokens[1]) as string;\r\n\r\n        // const errorMessage =\r\n        //   instruction.tokens.length == 5 &&\r\n        //   getTokenValue(instruction.tokens[2]) === '(' &&\r\n        //   getTokenValue(instruction.tokens[4]) === ')'\r\n        //     ? (getTokenValue(instruction.tokens[3]) as string)\r\n        //     : undefined;\r\n\r\n        const errMsg = this.createExpressionNode(instruction.tokens.slice(1));\r\n\r\n        ast.body.push(new RaiseNode(errorName, errMsg, getTokenLoc(firstToken)));\r\n      } else if (getTokenValue(firstToken) === 'for') {\r\n        const endDefOfDef = findTokenValueIndex(instruction.tokens, v => v === ':');\r\n\r\n        if (endDefOfDef === -1) {\r\n          throw `Can't find : for if`;\r\n        }\r\n\r\n        const itemVarName = getTokenValue(instruction.tokens[1]) as string;\r\n        const sourceArray = this.createExpressionNode(instruction.tokens.slice(3, endDefOfDef));\r\n        const forBody = getBody(instruction.tokens, endDefOfDef + 1);\r\n\r\n        ast.body.push(new ForNode(sourceArray, itemVarName, forBody, getTokenLoc(firstToken)));\r\n      } else if (getTokenValue(firstToken) === 'while') {\r\n        const endDefOfDef = findTokenValueIndex(instruction.tokens, v => v === ':');\r\n\r\n        if (endDefOfDef === -1) {\r\n          throw `Can't find : for [while]`;\r\n        }\r\n\r\n        const conditionTokens = instruction.tokens.slice(1, endDefOfDef);\r\n        const conditionNode = findIndexes(conditionTokens, OperationTypes.Logical, logicOpIndexes)\r\n          ? this.groupLogicalOperations(logicOpIndexes, conditionTokens)\r\n          : this.createExpressionNode(conditionTokens);\r\n\r\n        const body = getBody(instruction.tokens, endDefOfDef + 1);\r\n\r\n        ast.body.push(new WhileNode(conditionNode, body, getTokenLoc(firstToken)));\r\n      } else if (getTokenValue(firstToken) === 'import') {\r\n        let asIndex = findTokenValueIndex(instruction.tokens, v => v === 'as');\r\n        if (asIndex < 0) {\r\n          asIndex = instruction.tokens.length;\r\n        }\r\n\r\n        const module = {\r\n          name: instruction.tokens\r\n            .slice(1, asIndex)\r\n            .map(t => getTokenValue(t))\r\n            .join(''),\r\n          alias:\r\n            instruction.tokens\r\n              .slice(asIndex + 1)\r\n              .map(t => getTokenValue(t))\r\n              .join('') || undefined\r\n        } as NameAlias;\r\n\r\n        const body = {} as AstBlock; // empty for now\r\n        ast.body.push(new ImportNode(module, body, undefined, getTokenLoc(firstToken)));\r\n      } else if (getTokenValue(firstToken) === 'from') {\r\n        const importIndex = findTokenValueIndex(instruction.tokens, v => v === 'import');\r\n        if (importIndex < 0) {\r\n          throw Error(`'import' must follow 'from'`);\r\n        }\r\n\r\n        const module = {\r\n          name: instruction.tokens\r\n            .slice(1, importIndex)\r\n            .map(t => getTokenValue(t))\r\n            .join('')\r\n        } as NameAlias;\r\n\r\n        const parts = splitTokens(instruction.tokens.slice(importIndex + 1), ',').map(t => {\r\n          return {\r\n            name: getTokenValue(t[0]),\r\n            alias: t.length === 3 ? getTokenValue(t[2]) : undefined\r\n          } as NameAlias;\r\n        });\r\n\r\n        const body = {} as AstBlock; // empty for now\r\n\r\n        ast.body.push(new ImportNode(module, body, parts, getTokenLoc(firstToken)));\r\n      } else if (findIndexes(instruction.tokens, OperationTypes.Assignment, assignTokenIndexes)) {\r\n        const assignTokens = splitTokens(instruction.tokens, '=');\r\n        const target = this.createExpressionNode(assignTokens[0]);\r\n        const source = this.createExpressionNode(assignTokens[1]);\r\n        ast.body.push(new AssignNode(target, source, getTokenLoc(assignTokens[0][0])));\r\n      } else if (findIndexes(instruction.tokens, OperationTypes.Logical, logicOpIndexes)) {\r\n        ast.body.push(this.groupLogicalOperations(logicOpIndexes, instruction.tokens));\r\n      } else {\r\n        ast.body.push(this.createExpressionNode(instruction.tokens));\r\n      }\r\n    }\r\n  }\r\n\r\n  private sliceWithBrackets(a: Token[], begin: number, end: number): Token[] {\r\n    // if expression is in brackets, then we need clean brackets\r\n    if (getTokenValue(a[begin]) === '(' && getTokenType(a[begin]) !== TokenTypes.LiteralString) {\r\n      begin++;\r\n      end--;\r\n    }\r\n\r\n    return a.slice(begin, end);\r\n  }\r\n\r\n  private groupComparisonOperations(indexes: number[], tokens: Token[]): AstNode {\r\n    const start = 0;\r\n\r\n    let leftNode: AstNode | null = null;\r\n    for (let i = 0; i < indexes.length; i++) {\r\n      const opToken = getTokenValue(tokens[indexes[i]]) as ComparisonOperators;\r\n      leftNode = leftNode\r\n        ? leftNode\r\n        : this.createExpressionNode(this.sliceWithBrackets(tokens, start, indexes[i]));\r\n\r\n      const endInd = i + 1 < indexes.length ? indexes[i + 1] : tokens.length;\r\n      const rightNode = this.createExpressionNode(\r\n        this.sliceWithBrackets(tokens, indexes[i] + 1, endInd)\r\n      );\r\n\r\n      leftNode = new BinOpNode(leftNode, opToken, rightNode, getTokenLoc(tokens[0]));\r\n    }\r\n\r\n    return leftNode as AstNode;\r\n  }\r\n\r\n  private groupLogicalOperations(logicOp: number[], tokens: Token[]): LogicalOpNode {\r\n    let start = 0;\r\n    const logicItems: LogicalNodeItem[] = [];\r\n    for (let i = 0; i < logicOp.length; i++) {\r\n      const opToken = tokens[logicOp[i]];\r\n      const logicalSlice = this.sliceWithBrackets(tokens, start, logicOp[i]);\r\n      logicItems.push({\r\n        node: this.createExpressionNode(logicalSlice),\r\n        op: getTokenValue(opToken) as LogicalOperators\r\n      });\r\n\r\n      start = logicOp[i] + 1;\r\n    }\r\n\r\n    logicItems.push({\r\n      node: this.createExpressionNode(this.sliceWithBrackets(tokens, start, tokens.length))\r\n    } as LogicalNodeItem);\r\n\r\n    const lop = new LogicalOpNode(logicItems, getTokenLoc(tokens[0]));\r\n    return lop;\r\n  }\r\n\r\n  private tokensToInstructionLines(tokens: Token[], startLine: number): InstructionLine[] {\r\n    const lines: InstructionLine[] = [];\r\n\r\n    let column = 0;\r\n    let currentLine = startLine;\r\n    let line = new InstructionLine();\r\n    for (let i = 0; i < tokens.length; i++) {\r\n      const token = tokens[i];\r\n      const sLine = getStartLine(token);\r\n      const sColumn = getStartColumn(token);\r\n      const value = getTokenValue(token);\r\n      this._currentToken = token;\r\n\r\n      if (sLine >= startLine) {\r\n        if (currentLine !== sLine) {\r\n          currentLine = sLine;\r\n        }\r\n\r\n        if (column === sColumn && !')}]'.includes(value as string)) {\r\n          currentLine = sLine;\r\n          lines.push(line);\r\n          line = new InstructionLine();\r\n        }\r\n\r\n        line.tokens.push(token);\r\n\r\n        // first line defines a minimum indent\r\n        if (column === 0) {\r\n          column = sColumn;\r\n        }\r\n\r\n        // stop looping through if line has less indent\r\n        // it means the corrent block finished\r\n        if (sColumn < column) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (line.tokens.length) {\r\n      lines.push(line);\r\n    }\r\n\r\n    return lines;\r\n  }\r\n\r\n  private createExpressionNode(tokens: Token[]): AstNode {\r\n    if (tokens.length === 0) {\r\n      throw new Error(`Tokens length can't empty.`);\r\n    }\r\n    const lastToken = tokens[tokens.length - 1];\r\n    if (getTokenValue(lastToken) === ';' && getTokenType(lastToken) !== TokenTypes.LiteralString) {\r\n      throw new Error(`Unexpected symbol ';' in the end`);\r\n    }\r\n\r\n    this._currentToken = tokens[0];\r\n\r\n    // const or variable\r\n    if (tokens.length === 1 || (tokens.length === 2 && getTokenValue(tokens[1]) === '?')) {\r\n      const firstToken = tokens[0];\r\n      const tokenType = getTokenType(firstToken);\r\n\r\n      if (isTokenTypeLiteral(tokenType)) {\r\n        return new ConstNode(firstToken);\r\n      } else if (tokenType === TokenTypes.Identifier) {\r\n        return new GetSingleVarNode(\r\n          firstToken,\r\n          (tokens.length === 2 && getTokenValue(tokens[1]) === '?') || undefined\r\n        );\r\n      }\r\n\r\n      throw Error(`Unhandled single token: '${JSON.stringify(firstToken)}'`);\r\n    }\r\n\r\n    // arrow function\r\n    const arrowFuncParts = splitTokens(tokens, '=>');\r\n    if (arrowFuncParts.length > 1) {\r\n      const pArray =\r\n        getTokenValue(arrowFuncParts[0][0]) === '('\r\n          ? arrowFuncParts[0].splice(1, arrowFuncParts[0].length - 2)\r\n          : arrowFuncParts[0];\r\n      const params = splitTokens(pArray, ',').map(t => getTokenValue(t[0]) as string);\r\n\r\n      const instructionLines = this.tokensToInstructionLines(arrowFuncParts[1], 0);\r\n      const funcAst = {\r\n        name: this._moduleName,\r\n        body: [] as AstNode[],\r\n        funcs: [] as AstNode[]\r\n      } as AstBlock;\r\n      this.instructionsToNodes(instructionLines, funcAst);\r\n\r\n      return new ArrowFuncDefNode(funcAst, params, getTokenLoc(tokens[0]));\r\n    }\r\n\r\n    // comparison operations\r\n    const comparissonIndexes = findOperators(tokens, OperationTypes.Comparison);\r\n    if (comparissonIndexes.length) {\r\n      return this.groupComparisonOperations(comparissonIndexes, tokens);\r\n    }\r\n\r\n    // create arithmetic expression\r\n    const ops = findOperators(tokens);\r\n    if (ops.length) {\r\n      let prevNode: AstNode | null = null;\r\n      for (let i = 0; i < ops.length; i++) {\r\n        const opIndex = ops[i];\r\n        const op = getTokenValue(tokens[opIndex]) as Operators;\r\n\r\n        let nextOpIndex = i + 1 < ops.length ? ops[i + 1] : null;\r\n        let nextOp = nextOpIndex !== null ? getTokenValue(tokens[nextOpIndex]) : null;\r\n        if (nextOpIndex !== null && (nextOp === '*' || nextOp === '/')) {\r\n          let rightNode: AstNode | null = null;\r\n          // iterate through all continuous '*', '/' operations\r\n          do {\r\n            const nextOpIndex2 = i + 2 < ops.length ? ops[i + 2] : null;\r\n\r\n            const leftSlice2 = this.sliceWithBrackets(tokens, opIndex + 1, nextOpIndex);\r\n            const rightSlice2 = this.sliceWithBrackets(\r\n              tokens,\r\n              nextOpIndex + 1,\r\n              nextOpIndex2 || tokens.length\r\n            );\r\n\r\n            const left2 = this.createExpressionNode(leftSlice2);\r\n            const right2 = this.createExpressionNode(rightSlice2);\r\n            rightNode = new BinOpNode(left2, nextOp, right2, getTokenLoc(tokens[opIndex + 1]));\r\n\r\n            i++;\r\n            nextOpIndex = i + 1 < ops.length ? ops[i + 1] : null;\r\n            nextOp = nextOpIndex !== null ? getTokenValue(tokens[nextOpIndex]) : null;\r\n          } while (nextOpIndex !== null && (nextOp === '*' || nextOp === '/'));\r\n\r\n          // add up result\r\n          if (prevNode === null) {\r\n            const leftSlice = this.sliceWithBrackets(tokens, 0, opIndex);\r\n            prevNode = this.createExpressionNode(leftSlice);\r\n          }\r\n          prevNode = new BinOpNode(\r\n            prevNode,\r\n            op as ExpressionOperators,\r\n            rightNode,\r\n            getTokenLoc(tokens[0])\r\n          );\r\n        } else {\r\n          const leftSlice = prevNode ? [] : this.sliceWithBrackets(tokens, 0, opIndex);\r\n          const rightSlice = this.sliceWithBrackets(\r\n            tokens,\r\n            opIndex + 1,\r\n            nextOpIndex || tokens.length\r\n          );\r\n          const left: AstNode = prevNode || this.createExpressionNode(leftSlice);\r\n          const right = this.createExpressionNode(rightSlice);\r\n          prevNode = new BinOpNode(left, op as ExpressionOperators, right, getTokenLoc(tokens[0]));\r\n        }\r\n      }\r\n\r\n      if (prevNode === null) {\r\n        throw Error(`Can't create node ...`);\r\n      }\r\n\r\n      return prevNode;\r\n    }\r\n\r\n    // create chaining calls\r\n\r\n    const inds = findChainingCallTokensIndexes(tokens);\r\n\r\n    if (inds.length > 0) {\r\n      const chainingGroup = splitTokensByIndexes(tokens, inds);\r\n      const innerNodes: AstNode[] = [];\r\n\r\n      for (let i = 0; i < chainingGroup.length; i++) {\r\n        const chainLinkTokenks = chainingGroup[i];\r\n\r\n        if (i !== 0 && getTokenValue(chainLinkTokenks[0]) === '[') {\r\n          const nullCoelsing = getTokenValue(chainLinkTokenks[chainLinkTokenks.length - 1]) === '?';\r\n          if (nullCoelsing) {\r\n            chainLinkTokenks.pop();\r\n          }\r\n          const paramsTokensSlice = chainLinkTokenks.slice(1, chainLinkTokenks.length - 1);\r\n          const paramsNodes = this.createExpressionNode(paramsTokensSlice);\r\n\r\n          innerNodes.push(\r\n            new ChainingObjectAccessNode(\r\n              paramsNodes,\r\n              nullCoelsing,\r\n              getTokenLoc(chainLinkTokenks[0])\r\n            )\r\n          );\r\n          continue;\r\n        }\r\n\r\n        innerNodes.push(this.createExpressionNode(chainLinkTokenks));\r\n      }\r\n\r\n      return new ChainingCallsNode(innerNodes, getTokenLoc(tokens[0]));\r\n    }\r\n\r\n    // create function call node\r\n    if (tokens.length > 2 && getTokenValue(tokens[1]) === '(') {\r\n      const isNullCoelsing = getTokenValue(tokens[tokens.length - 1]) === '?';\r\n      if (isNullCoelsing) {\r\n        // remove '?'\r\n        tokens.pop();\r\n      }\r\n      const name = getTokenValue(tokens[0]) as string;\r\n      const paramsTokensSlice = tokens.slice(2, tokens.length - 1);\r\n      const paramsTokens = splitTokens(paramsTokensSlice, ',');\r\n      const paramsNodes = paramsTokens.map(tkns => this.createExpressionNode(tkns));\r\n      const node = new FunctionCallNode(name, paramsNodes, getTokenLoc(tokens[0]));\r\n      node.nullCoelsing = isNullCoelsing || undefined;\r\n      return node;\r\n    }\r\n\r\n    // create Object Node\r\n    if (getTokenValue(tokens[0]) === '{' && getTokenValue(tokens[tokens.length - 1]) === '}') {\r\n      const keyValueTokens = splitTokens(tokens.splice(1, tokens.length - 2), ',');\r\n      const props = [] as ObjectPropertyInfo[];\r\n      for (let i = 0; i < keyValueTokens.length; i++) {\r\n        const keyValue = splitTokens(keyValueTokens[i], ':');\r\n        if (keyValue.length === 1) {\r\n          const pInfo = {\r\n            name: new ConstNode(keyValue[0][0]),\r\n            value: this.createExpressionNode(keyValue[0])\r\n          } as ObjectPropertyInfo;\r\n\r\n          props.push(pInfo);\r\n        } else if (keyValue.length === 2) {\r\n          let name: AstNode | null = null;\r\n          const namePart = keyValue[0];\r\n\r\n          if (namePart.length === 1) {\r\n            name = new ConstNode(namePart[0]);\r\n          } else if (\r\n            getTokenValue(namePart[0]) === '[' &&\r\n            getTokenValue(namePart[namePart.length - 1]) === ']'\r\n          ) {\r\n            name = this.createExpressionNode(namePart.slice(1, namePart.length - 1));\r\n          } else {\r\n            throw new Error(\r\n              `Incorrect JSON. Can't resolve Key field. That should either constant or expression in []`\r\n            );\r\n          }\r\n\r\n          const pInfo = {\r\n            name,\r\n            value: this.createExpressionNode(keyValue[1])\r\n          } as ObjectPropertyInfo;\r\n\r\n          props.push(pInfo);\r\n        } else {\r\n          throw Error('Incorrect JSON');\r\n        }\r\n      }\r\n\r\n      return new CreateObjectNode(props, getTokenLoc(tokens[0]));\r\n    }\r\n\r\n    // create Array Node\r\n    if (getTokenValue(tokens[0]) === '[' && getTokenValue(tokens[tokens.length - 1]) === ']') {\r\n      const items = splitTokens(tokens.splice(1, tokens.length - 2), ',').map(tkns =>\r\n        this.createExpressionNode(tkns)\r\n      );\r\n\r\n      return new CreateArrayNode(items, getTokenLoc(tokens[0]));\r\n    }\r\n\r\n    throw Error(`Undefined node '${getTokenValue(tokens[0])}'.`);\r\n  }\r\n}\r\n","import { getTokenType, getTokenValue, Token, TokenTypes } from '../common';\r\n\r\nconst SeparatorsMap: Record<string, string[]> = {\r\n  '\\n': ['\\n'],\r\n  '=': ['=', '==', '=>'],\r\n\r\n  '+': ['+', '++', '+='],\r\n  '-': ['-', '--', '-='],\r\n  '*': ['*', '**', '*='],\r\n  '/': ['/', '//', '/='],\r\n\r\n  '.': ['.'],\r\n  '?': ['?'],\r\n  '!': ['!='],\r\n  ':': [':'],\r\n  ',': [','],\r\n\r\n  '>': ['>', '>='],\r\n  '<': ['<', '<=', '<>'],\r\n\r\n  '(': ['('],\r\n  ')': [')'],\r\n  '{': ['{'],\r\n  '}': ['}'],\r\n  '[': ['['],\r\n  ']': [']']\r\n};\r\n\r\nconst escapeChars = ['\"', \"'\", '\\\\'];\r\nconst Keywords: string[] = ['async', 'def', 'for', 'while', 'if', 'return', 'in'];\r\n\r\nexport class Tokenizer {\r\n  private _startLine = 1;\r\n  private _startColumn = 1;\r\n  private _currentLine = 1;\r\n  private _currentColumn = 1;\r\n  private _tokenText = '';\r\n  private _cursor = 0;\r\n  private _script = '';\r\n\r\n  private get tokenText(): string {\r\n    return this._tokenText;\r\n  }\r\n  private set tokenText(value: string) {\r\n    if (!this._tokenText && value) {\r\n      this._startLine = this._currentLine;\r\n      this._startColumn = this._currentColumn;\r\n    }\r\n    this._tokenText = value;\r\n  }\r\n\r\n  /**\r\n   * Splits script code into a tokens\r\n   * @param script A jsPython text\r\n   */\r\n  tokenize(script: string): Token[] {\r\n    if (!script || !script.length) {\r\n      return [];\r\n    }\r\n\r\n    script = script\r\n      // eslint-disable-next-line no-control-regex\r\n      .replace(new RegExp('\\t', 'g'), '  ') // replace all tabs with 2 spaces\r\n      // eslint-disable-next-line no-control-regex\r\n      .replace(new RegExp('\\r', 'g'), ''); // remove all \\r symbols\r\n    this._script = script;\r\n\r\n    this._cursor = 0;\r\n    this._startLine = 1;\r\n    this._startColumn = 1;\r\n    this._currentLine = 1;\r\n    this._currentColumn = 1;\r\n\r\n    const tokens: Token[] = [];\r\n\r\n    let first = true;\r\n    // handle initial spaces\r\n    while (script[this._cursor] === '\\n') {\r\n      this.incrementCursor();\r\n      if (first) {\r\n        this._currentLine++;\r\n        first = false;\r\n      }\r\n      this._currentColumn = 1;\r\n    }\r\n\r\n    do {\r\n      const symbol = script[this._cursor];\r\n\r\n      if (symbol == ' ' && this.tokenText.length !== 0) {\r\n        this.tokenText = this.processToken(this.tokenText, tokens);\r\n        continue;\r\n      } else if (SeparatorsMap[symbol] !== undefined && !this.isPartOfNumber(symbol, tokens)) {\r\n        // handle numbers with floating point e.g. 3.14\r\n        this.tokenText = this.processToken(this.tokenText, tokens);\r\n        this.tokenText = symbol;\r\n\r\n        const sepsMap = SeparatorsMap[symbol];\r\n\r\n        if (sepsMap.length >= 1) {\r\n          // process longer operators\r\n          while (sepsMap.includes(this.tokenText + script[this._cursor + 1])) {\r\n            this.tokenText += script[this.incrementCursor()];\r\n          }\r\n        }\r\n        this.tokenText = this.processToken(this.tokenText, tokens, false, TokenTypes.Operator);\r\n      } else if (symbol === '#') {\r\n        let first = true;\r\n        while (script[this.incrementCursor()] !== '\\n') {\r\n          this.tokenText += script[this._cursor];\r\n\r\n          // correct start column\r\n          if (first) {\r\n            first = false;\r\n            this._startColumn = this._startColumn - 1;\r\n          }\r\n\r\n          if (this._cursor + 1 >= script.length) break;\r\n        }\r\n        this.tokenText = this.processToken(this.tokenText, tokens, true, TokenTypes.Comment);\r\n      } else if (symbol === '\"' || symbol === \"'\") {\r\n        // remember either it is single or double quote\r\n        const q = symbol;\r\n        // we are not expecting token to be added here.\r\n        // it should pass a failt to parser\r\n        this.tokenText = this.processToken(this.tokenText, tokens);\r\n\r\n        // handle \"\"\" comment \"\"\"\"\r\n        if (script[this._cursor + 1] === q && script[this._cursor + 2] === q) {\r\n          const cLine = this._currentLine;\r\n          const cColumn = this._currentColumn;\r\n          this.incrementCursor(2);\r\n          const passCond = true;\r\n          while (passCond) {\r\n            this.tokenText += script[this.incrementCursor()];\r\n            if (\r\n              this._cursor + 3 >= script.length ||\r\n              (script[this._cursor + 1] === q &&\r\n                script[this._cursor + 2] === q &&\r\n                script[this._cursor + 3] === q)\r\n            ) {\r\n              break;\r\n            }\r\n          }\r\n          // a special case when multiline string\r\n          this._startLine = cLine;\r\n          this._startColumn = cColumn;\r\n\r\n          this.incrementCursor(3);\r\n        } else {\r\n          while (script[this.incrementCursor()] !== q) {\r\n            if (\r\n              script[this._cursor] === '\\\\' &&\r\n              escapeChars.indexOf(script[this._cursor + 1]) >= 0\r\n            ) {\r\n              this._cursor++;\r\n            }\r\n\r\n            this.tokenText += script[this._cursor];\r\n            if (this._cursor + 1 >= script.length) {\r\n              throw new Error(`Line ${this._startLine}: End of string missing.`);\r\n            }\r\n          }\r\n\r\n          //start column needs to take into account a begining quote, not just a string\r\n          this._startColumn--;\r\n        }\r\n\r\n        // a special case when empty string\r\n        if (this.tokenText.length === 0) {\r\n          this._startLine = this._currentLine;\r\n          this._startColumn = this._currentColumn;\r\n        }\r\n        this.tokenText = this.processToken(this.tokenText, tokens, true, TokenTypes.LiteralString);\r\n      } else if (symbol != ' ') {\r\n        this.tokenText += symbol;\r\n      }\r\n    } while (this.incrementCursor() < script.length);\r\n\r\n    this.processToken(this.tokenText, tokens);\r\n\r\n    return tokens;\r\n  }\r\n\r\n  private incrementCursor(count = 1): number {\r\n    for (let i = 0; i < count; i++) {\r\n      this._cursor = this._cursor + 1;\r\n      if (this._script[this._cursor] === '\\n') {\r\n        this._currentLine++;\r\n        this._currentColumn = 0;\r\n      } else {\r\n        this._currentColumn++;\r\n      }\r\n    }\r\n\r\n    return this._cursor;\r\n  }\r\n\r\n  private recognizeToken(\r\n    tokenText: string,\r\n    type: TokenTypes | null = null\r\n  ): { value: string | number | boolean | null; type: TokenTypes } {\r\n    let value: string | number | boolean | null = tokenText;\r\n\r\n    if (type === null) {\r\n      if (tokenText === 'null') {\r\n        type = TokenTypes.LiteralNull;\r\n        value = null;\r\n      } else if (tokenText === 'true' || tokenText === 'false') {\r\n        type = TokenTypes.LiteralBool;\r\n        value = tokenText === 'true';\r\n      } else if (this.parseNumberOrNull(tokenText) !== null) {\r\n        type = TokenTypes.LiteralNumber;\r\n        value = this.parseNumberOrNull(tokenText);\r\n      } else if (Keywords.indexOf(tokenText) >= 0) {\r\n        type = TokenTypes.Keyword;\r\n      } else {\r\n        type = TokenTypes.Identifier;\r\n      }\r\n    }\r\n\r\n    return {\r\n      value: value,\r\n      type: type\r\n    };\r\n  }\r\n\r\n  private processToken(\r\n    strToken: string,\r\n    tokens: Token[],\r\n    allowEmptyString = false,\r\n    type: TokenTypes | null = null\r\n  ): string {\r\n    // ignore empty tokens\r\n    if ((!strToken.length && !allowEmptyString) || strToken === '\\n') return '';\r\n\r\n    const token = this.recognizeToken(strToken, type);\r\n    tokens.push([\r\n      token.value,\r\n      Uint16Array.of(\r\n        token.type as number,\r\n        this._startLine,\r\n        this._startColumn,\r\n        this._currentLine,\r\n        this._currentColumn\r\n      )\r\n    ] as Token);\r\n    return '';\r\n  }\r\n\r\n  private parseNumberOrNull(value: string | number): number | null {\r\n    if (typeof value === 'number') {\r\n      return value;\r\n    }\r\n\r\n    if (!value || typeof value !== 'string') {\r\n      return null;\r\n    }\r\n\r\n    value = value.trim();\r\n\r\n    // Just to make sure string contains digits only and '.', ','. Otherwise, parseFloat can incorrectly parse into number\r\n    for (let i = value.length - 1; i >= 0; i--) {\r\n      const d = value.charCodeAt(i);\r\n      if (d < 48 || d > 57) {\r\n        // '.' - 46 ',' - 44 '-' - 45(but only first char)\r\n        if (d !== 46 && d !== 44 && (d !== 45 || i !== 0)) return null;\r\n      }\r\n    }\r\n\r\n    const res = parseFloat(value);\r\n    return !isNaN(res) ? res : null;\r\n  }\r\n\r\n  private isPartOfNumber(symbol: string, currentTokens: Token[]): boolean {\r\n    if (symbol === '-' && !this.tokenText.length) {\r\n      // '-' needs to be handled e.g. -3; 2 + -2 etc\r\n      const prevToken = currentTokens.length !== 0 ? currentTokens[currentTokens.length - 1] : null;\r\n      return (\r\n        prevToken === null ||\r\n        (getTokenType(prevToken) === TokenTypes.Operator && getTokenValue(prevToken) !== ')')\r\n      );\r\n    } else if (symbol === '.' && this.parseNumberOrNull(this.tokenText) !== null) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n}\r\n","import { AstBlock, ImportNode, Token } from './common';\r\nimport { getImportType } from './common/utils';\r\nimport { Evaluator } from './evaluator';\r\nimport { EvaluatorAsync } from './evaluator/evaluatorAsync';\r\nimport { BlockContext, Scope } from './evaluator/scope';\r\nimport { INITIAL_SCOPE, PackageToImport } from './initialScope';\r\nimport { Parser } from './parser';\r\nimport { Tokenizer } from './tokenizer';\r\n\r\nexport type PackageLoader = (packageName: string) => Record<string, unknown>;\r\nexport type ModuleLoader = (filePath: string) => Promise<string>;\r\n\r\nexport function jsPython(): Interpreter {\r\n  return Interpreter.create();\r\n}\r\n\r\nexport class Interpreter {\r\n  private readonly initialScope: Record<string, unknown> = { ...INITIAL_SCOPE };\r\n\r\n  private _lastExecutionContext: Record<string, unknown> | null = null;\r\n\r\n  private packageLoader?: PackageLoader;\r\n  private moduleLoader?: ModuleLoader;\r\n\r\n  static create(): Interpreter {\r\n    return new Interpreter();\r\n  }\r\n\r\n  get initialExecutionContext(): Record<string, unknown> {\r\n    return this.initialScope;\r\n  }\r\n\r\n  get lastExecutionContext(): Record<string, unknown> | null {\r\n    return this._lastExecutionContext;\r\n  }\r\n\r\n  cleanUp(): void {\r\n    this._lastExecutionContext = null;\r\n  }\r\n\r\n  jsPythonInfo(): string {\r\n    return INITIAL_SCOPE.jsPython();\r\n  }\r\n\r\n  tokenize(script: string): Token[] {\r\n    const tokenizer = new Tokenizer();\r\n    return tokenizer.tokenize(script);\r\n  }\r\n\r\n  parse(script: string, moduleName = 'main.jspy'): AstBlock {\r\n    const tokenizer = new Tokenizer();\r\n    const parser = new Parser();\r\n    const jspyAst = parser.parse(tokenizer.tokenize(script), moduleName);\r\n    return jspyAst;\r\n  }\r\n\r\n  eval(\r\n    codeOrAst: string | AstBlock,\r\n    scope: Record<string, unknown> = {},\r\n    entryFunctionName: string | [string, ...unknown[]] = '',\r\n    moduleName = 'main.jspy'\r\n  ): unknown {\r\n    const ast =\r\n      typeof codeOrAst === 'string'\r\n        ? this.parse(codeOrAst as string, moduleName)\r\n        : (codeOrAst as AstBlock);\r\n\r\n    const blockContext = {\r\n      moduleName: moduleName,\r\n      cancellationToken: { cancel: false },\r\n      blockScope: new Scope(scope)\r\n    } as BlockContext;\r\n\r\n    blockContext.blockScope.set('printExecutionContext', () =>\r\n      console.log(blockContext.blockScope.getScope())\r\n    );\r\n    blockContext.blockScope.set('getExecutionContext', () => blockContext.blockScope.getScope());\r\n    this._lastExecutionContext = blockContext.blockScope.getScope();\r\n\r\n    const result = new Evaluator().evalBlock(ast, blockContext);\r\n    if (!entryFunctionName || !entryFunctionName.length) {\r\n      return result;\r\n    } else {\r\n      const funcName = Array.isArray(entryFunctionName)? entryFunctionName[0] : entryFunctionName as string\r\n      const funcParams = Array.isArray(entryFunctionName)? entryFunctionName.slice(1) : []\r\n      const func = blockContext.blockScope.get(funcName);\r\n      if (typeof func !== 'function') {\r\n        throw Error(`Function ${entryFunctionName} does not exists or not a function`);\r\n      }\r\n      return func(...funcParams);\r\n    }\r\n  }\r\n\r\n  async evalAsync(\r\n    codeOrAst: string | AstBlock,\r\n    scope: Record<string, unknown> = {},\r\n    entryFunctionName: string | [string, ...unknown[]] = '',\r\n    moduleName = 'main.jspy',\r\n    ctxInitialized?: (ctx: BlockContext) => void\r\n  ): Promise<unknown> {\r\n    const ast =\r\n      typeof codeOrAst === 'string'\r\n        ? this.parse(codeOrAst as string, moduleName)\r\n        : (codeOrAst as AstBlock);\r\n    const evaluator = new EvaluatorAsync();\r\n    const blockContext = {\r\n      moduleName: moduleName,\r\n      cancellationToken: { cancel: false },\r\n      blockScope: new Scope(scope)\r\n    } as BlockContext;\r\n\r\n    if (typeof ctxInitialized === 'function') {\r\n      ctxInitialized(blockContext);\r\n    }\r\n\r\n    blockContext.blockScope.set('printExecutionContext', () =>\r\n      console.log(blockContext.blockScope.getScope())\r\n    );\r\n    blockContext.blockScope.set('getExecutionContext', () => blockContext.blockScope.getScope());\r\n    this._lastExecutionContext = blockContext.blockScope.getScope();\r\n\r\n    const result = await evaluator\r\n      .registerJsonFileLoader(\r\n        async (modulePath: string) =>\r\n          await (this.moduleLoader\r\n            ? this.moduleLoader(modulePath)\r\n            : Promise.reject('ModuleLoader is not registered'))\r\n      )\r\n      .registerModuleParser(async modulePath => await this.moduleParser(modulePath))\r\n      .registerBlockContextFactory((moduleName, ast: AstBlock) => {\r\n        // enrich context\r\n        const newContext = this.assignImportContext(ast, scope);\r\n        const moduleContext = {\r\n          moduleName,\r\n          blockScope: new Scope(newContext),\r\n          cancellationToken: blockContext.cancellationToken\r\n        };\r\n        moduleContext.blockScope.set('printExecutionContext', () =>\r\n          console.log(moduleContext.blockScope.getScope())\r\n        );\r\n        moduleContext.blockScope.set('getExecutionContext', () =>\r\n          moduleContext.blockScope.getScope()\r\n        );\r\n        return moduleContext;\r\n      })\r\n      .evalBlockAsync(ast, blockContext);\r\n\r\n    if (!entryFunctionName || !entryFunctionName.length) {\r\n      return result;\r\n    } else {\r\n      const funcName = Array.isArray(entryFunctionName)? entryFunctionName[0] : entryFunctionName as string\r\n      const funcParams = Array.isArray(entryFunctionName)? entryFunctionName.slice(1) : []\r\n\r\n      const func = blockContext.blockScope.get(funcName);\r\n      if (typeof func !== 'function') {\r\n        throw Error(`Function ${entryFunctionName} does not exists or not a function`);\r\n      }\r\n      return await func(...funcParams);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Compatibility method (with v1). !\r\n   */\r\n  async evaluate(\r\n    script: string,\r\n    context: Record<string, unknown> = {},\r\n    entryFunctionName: string | [string, ...unknown[]] = '',\r\n    moduleName = 'main.jspy',\r\n    ctxInitialized?: (ctx: BlockContext) => void\r\n  ): Promise<unknown> {\r\n    if (!script || !script.length) {\r\n      return null;\r\n    }\r\n    const ast = this.parse(script, moduleName);\r\n\r\n    context = context && typeof context === 'object' ? context : {};\r\n    context = this.assignImportContext(ast, context);\r\n\r\n    const globalScope = {\r\n      ...this.initialScope,\r\n      ...context\r\n    } as Record<string, unknown>;\r\n\r\n    return await this.evalAsync(ast, globalScope, entryFunctionName, moduleName, ctxInitialized);\r\n  }\r\n\r\n  registerPackagesLoader(loader: PackageLoader): Interpreter {\r\n    if (typeof loader === 'function') {\r\n      this.packageLoader = loader;\r\n    } else {\r\n      throw Error('PackagesLoader');\r\n    }\r\n    return this;\r\n  }\r\n\r\n  registerModuleLoader(loader: ModuleLoader): Interpreter {\r\n    if (typeof loader === 'function') {\r\n      this.moduleLoader = loader;\r\n    } else {\r\n      throw Error('ModuleLoader should be a function');\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  addFunction(\r\n    funcName: string,\r\n    fn: (...args: unknown[]) => void | unknown | Promise<unknown>\r\n  ): Interpreter {\r\n    this.initialScope[funcName] = fn;\r\n    return this;\r\n  }\r\n\r\n  assignGlobalContext(obj: Record<string, unknown>): Interpreter {\r\n    Object.assign(this.initialScope, obj);\r\n    return this;\r\n  }\r\n\r\n  hasFunction(scripts = '', funcName: string): boolean {\r\n    return scripts.indexOf(`def ${funcName}`) > -1;\r\n  }\r\n\r\n  private assignImportContext(\r\n    ast: AstBlock,\r\n    context: Record<string, unknown>\r\n  ): Record<string, unknown> {\r\n    const nodeToPackage = (im: ImportNode): PackageToImport => {\r\n      return {\r\n        name: im.module.name,\r\n        as: im.module.alias,\r\n        properties: im.parts?.map(p => ({ name: p.name, as: p.alias }))\r\n      } as PackageToImport;\r\n    };\r\n\r\n    const importNodes = ast.body.filter(n => n.type === 'import') as ImportNode[];\r\n\r\n    const jsImport = importNodes\r\n      .filter(im => getImportType(im.module.name) === 'jsPackage')\r\n      .map(im => nodeToPackage(im));\r\n\r\n    if (jsImport.length && this.packageLoader) {\r\n      const libraries = this.packageResolver(jsImport);\r\n      context = { ...context, ...libraries };\r\n    }\r\n\r\n    return context as Record<string, unknown>;\r\n  }\r\n\r\n  private async moduleParser(modulePath: string): Promise<AstBlock> {\r\n    if (!this.moduleLoader) {\r\n      throw new Error('Module Loader is not registered');\r\n    }\r\n\r\n    const content = await this.moduleLoader(modulePath);\r\n    return this.parse(content, modulePath);\r\n  }\r\n\r\n  private packageResolver(packages: PackageToImport[]): Record<string, unknown> {\r\n    if (!this.packageLoader) {\r\n      throw Error('Package loader not provided.');\r\n    }\r\n    const libraries: Record<string, unknown> = {};\r\n    packages.forEach(({ name, as, properties }: PackageToImport) => {\r\n      const lib = (this.packageLoader && this.packageLoader(name)) || {};\r\n      if (properties?.length) {\r\n        properties.forEach(prop => {\r\n          libraries[prop.as || prop.name] = lib[prop.name];\r\n        });\r\n      } else if (as) {\r\n        libraries[as] = lib;\r\n      } else {\r\n        libraries[name] = lib;\r\n      }\r\n      if (as) {\r\n        libraries[as] = lib;\r\n      }\r\n    });\r\n    return libraries;\r\n  }\r\n}\r\n"],"names":["getImportType","name","startsWith","endsWith","jspyErrorMessage","error","module","line","column","message","concat","_super","JspyTokenizerError","_this","this","Object","setPrototypeOf","prototype","__extends","Error","OperationTypes","JspyParserError","JspyEvalError","JspyError","TokenTypes","OperatorsMap","Arithmetic","Comparison","and","Logical","or","in","Membership","Assignment","OperationFuncs","l","r","arithmeticOperation","comparissonOperation","logicalOperation","op","includes","String","Array","isArray","membershipOperation","Math","pow","getTokenType","token","getTokenValue","getTokenLoc","subarray","getStartLine","getStartColumn","splitTokensByIndexes","tokens","sepIndexes","result","length","start","i","ind","push","slice","splitTokens","separator","findTokenValueIndexes","value","findTokenValueIndex","predicate","LiteralString","skipInnerBrackets","opIndexes","tValue","findOperators","operationType","undefined","openChar","closeChar","innerBrackets","tokenValue","AstNode","type","loc","AssignNode","target","source","call","ConstNode","CommentNode","comment","ReturnNode","returnValue","RaiseNode","errorName","errorMessageAst","ContinueNode","BreakNode","SetSingleVarNode","FunctionCallNode","paramNodes","nullCoelsing","FunctionDefNode","funcAst","params","isAsync","ArrowFuncDefNode","ElifNode","conditionNode","elifBody","IfNode","ifBody","elifs","elseBody","TryExceptNode","tryBody","exepts","finallyBody","ForNode","sourceArray","itemVarName","body","WhileNode","condition","ImportNode","parts","GetSingleVarNode","ChainingCallsNode","innerNodes","CreateObjectNode","props","CreateArrayNode","items","ChainingObjectAccessNode","indexerBody","LogicalOpNode","BinOpNode","left","right","cloneContext","context","moduleName","blockScope","clone","cancellationToken","Scope","initialScope","scope","__assign","getScope","set","key","get","Evaluator","evalBlock","ast","blockContext","lastResult","node","funcDef","args","_i","arguments","jspyFuncInvoker","apply","_a","funcs","cancel","evalNode","returnCalled","res","returnObject","continueCalled","breakCalled","err","assign","argValue","invokeFunction","func","fps","raiseNode","errorMessage","returnNode","name_2","charAt","binOpNode","logicalGroups","gResult","eg","arrowFuncDef_1","funcCallNode","pms","_g","map","n","assignNode","node_1","targetNode","targetObjectNode","targetObject","lastInnerNode","lastPropertyName","resolveChainingCallsNode","obj","_h","p","_j","_k","item","whileNode","forNode","array","tryNode","_b","name_1","_c","firstExept","catchBody","ctx","_d","alias","_e","_f","ifNode","doElse","elIfNode","chNode","startObject","nestedProp","bind","EvaluatorAsync","moduleParser","Promise","reject","jsonFileLoader","registerModuleParser","registerJsonFileLoader","registerBlockContextFactory","blockContextFactory","evalBlockAsync","newScope","invoker","jspyFuncInvokerAsync","__spreadArray","iType","importNode","JSON","parse","jsonValue","sent","defaultModuleName","moduleAst","moduleBlockContext","assignFunctionsToScope","evalNodeAsync","err_1","filter","f","indexOf","substring","lastIndexOf","invokeFunctionAsync","_0","err_2","_l","_o","_m","_p","_q","_r","_t","_s","_u","_v","_x","_w","_z","_y","INITIAL_SCOPE","jsPython","dateTime","str","Date","isNaN","valueOf","strValue","parseMonth","mm","NaN","m","parseInt","correctYear","yy","validDateOrNull","yyyy","month","day","hours","mins","ss","dd","strTokens","replace","toLowerCase","split","dt","parseFloat","d","parseDatetimeOrNull","range","stop","step","arr","isStopNaN","print","console","log","isNull","v","defValue","isDate","isFunction","isString","deleteProperty","propName","printExecutionContext","getExecutionContext","InstructionLine","startLine","startColumn","endLine","endColumn","Parser","_currentToken","_moduleName","instructions","tokensToInstructionLines","instructionsToNodes","getBody","startTokenIndex","instructionLines","bodyAst","findIndexes","tkns","operation","splice","forEach","instruction","tt","Comment","firstToken","secondToken","logicOpIndexes","funcName","findIndex","t","endDefOfDef","conditionTokens","groupLogicalOperations","createExpressionNode","elifNodes","elifInstruction","endOfElif","conditionTokens_1","elifConditionNode","excepts","endIndex","except","errMsg","forBody","asIndex","module_1","join","importIndex","module_2","assignTokens","sliceWithBrackets","a","begin","end","groupComparisonOperations","indexes","leftNode","opToken","endInd","rightNode","logicOp","logicItems","logicalSlice","lines","sLine","sColumn","lastToken","tokenType","LiteralNumber","LiteralBool","LiteralNull","isTokenTypeLiteral","Identifier","stringify","arrowFuncParts","comparissonIndexes","ops","prevNode","opIndex","nextOpIndex","nextOp","leftSlice","rightSlice","nextOpIndex2","leftSlice2","rightSlice2","left2","right2","inds","findChainingCallTokensIndexes","chainingGroup","chainLinkTokenks","pop","paramsTokensSlice","paramsNodes","isNullCoelsing","keyValueTokens","keyValue","pInfo","namePart","SeparatorsMap","escapeChars","Keywords","Tokenizer","_startLine","_startColumn","_currentLine","_currentColumn","_tokenText","_cursor","_script","defineProperty","tokenize","script","RegExp","first","incrementCursor","symbol","tokenText","isPartOfNumber","first_1","processToken","q","cLine","cColumn","sepsMap","Operator","count","recognizeToken","parseNumberOrNull","Keyword","strToken","allowEmptyString","Uint16Array","of","trim","charCodeAt","currentTokens","prevToken","Interpreter","_lastExecutionContext","create","cleanUp","jsPythonInfo","tokenizer","eval","codeOrAst","entryFunctionName","funcParams","evalAsync","ctxInitialized","evaluator","modulePath","__awaiter","moduleLoader","__generator","newContext","assignImportContext","moduleContext","evaluate","globalScope","registerPackagesLoader","loader","packageLoader","registerModuleLoader","addFunction","fn","assignGlobalContext","hasFunction","scripts","jsImport","im","as","properties","nodeToPackage","libraries","packageResolver","content","packages","lib","prop","exports"],"mappings":"y6EAwIM,SAAUA,EAAcC,GAC5B,OAAIA,EAAKC,WAAW,MAAQD,EAAKC,WAAW,MACnCD,EAAKE,SAAS,SAAW,OAAS,aAGpC,WACT,CAEA,SAASC,EACPC,EACAC,EACAC,EACAC,EACAC,GAEA,MAAO,GAAAC,OAAGL,EAAK,MAAAK,OAAKJ,EAAM,KAAAI,OAAIH,EAAI,KAAAG,OAAIF,EAAM,OAAAE,OAAMD,EACpD,EAEA,SAAAE,GACE,SAAAC,EACSN,EACAC,EACAC,EACAC,GAJT,IAAAI,EAMEF,cAGDG,YARQD,EAAMP,OAANA,EACAO,EAAIN,KAAJA,EACAM,EAAML,OAANA,EACAK,EAAOJ,QAAPA,EAGPI,EAAKJ,QAAUL,EAAiB,qBAAsBE,EAAQC,EAAMC,EAAQC,GAC5EM,OAAOC,eAAeH,EAAMD,EAAmBK,YAChD,CAVqCC,EAAKN,EAAAD,EAA7C,CAAA,CAAwCQ,OAaxC,ICvKYC,EDuKZC,EAAA,SAAAV,GACE,SAAAU,EACSf,EACAC,EACAC,EACAC,GAJT,IAAAI,EAMEF,cAGDG,YARQD,EAAMP,OAANA,EACAO,EAAIN,KAAJA,EACAM,EAAML,OAANA,EACAK,EAAOJ,QAAPA,EAGPI,EAAKJ,QAAUL,EAAiB,kBAAmBE,EAAQC,EAAMC,EAAQC,GACzEM,OAAOC,eAAeH,EAAMQ,EAAgBJ,YAC7C,CACH,OAXqCC,EAAKG,EAAAV,GAWzCU,CAAD,CAXA,CAAqCF,OAarCG,EAAA,SAAAX,GACE,SAAAW,EACShB,EACAC,EACAC,EACAC,GAJT,IAAAI,EAMEF,cAGDG,YARQD,EAAMP,OAANA,EACAO,EAAIN,KAAJA,EACAM,EAAML,OAANA,EACAK,EAAOJ,QAAPA,EAGPI,EAAKJ,QAAUL,EAAiB,gBAAiBE,EAAQC,EAAMC,EAAQC,GACvEM,OAAOC,eAAeH,EAAMS,EAAcL,YAC3C,CACH,OAXmCC,EAAKI,EAAAX,GAWvCW,CAAD,CAXA,CAAmCH,OAanCI,EAAA,SAAAZ,GACE,SACSY,EAAAjB,EACAC,EACAC,EACAP,EACAQ,GALT,IAAAI,EAOEF,cAGDG,YATQD,EAAMP,OAANA,EACAO,EAAIN,KAAJA,EACAM,EAAML,OAANA,EACAK,EAAIZ,KAAJA,EACAY,EAAOJ,QAAPA,EAGPI,EAAKJ,QAAUL,EAAiB,YAAaE,GAAU,YAAaC,EAAMC,EAAQC,GAClFM,OAAOC,eAAeH,EAAMU,EAAUN,YACvC,CACH,OAZ+BC,EAAKK,EAAAZ,GAYnCY,CAAD,CAZA,CAA+BJ,QCjM/B,SAAYC,GACVA,EAAAA,EAAA,WAAA,GAAA,aACAA,EAAAA,EAAA,WAAA,GAAA,aACAA,EAAAA,EAAA,WAAA,GAAA,aACAA,EAAAA,EAAA,QAAA,GAAA,UACAA,EAAAA,EAAA,WAAA,GAAA,YACD,CAND,CAAYA,IAAAA,EAMX,CAAA,IAeM,ICnBKI,EDmBCC,EAAkD,CAC7D,IAAKL,EAAeM,WACpB,IAAKN,EAAeM,WACpB,IAAKN,EAAeM,WACpB,IAAKN,EAAeM,WACpB,IAAKN,EAAeM,WACpB,KAAMN,EAAeM,WACrB,KAAMN,EAAeM,WAErB,IAAKN,EAAeO,WACpB,KAAMP,EAAeO,WACrB,KAAMP,EAAeO,WACrB,KAAMP,EAAeO,WACrB,KAAMP,EAAeO,WACrB,IAAKP,EAAeO,WACpB,KAAMP,EAAeO,WAErBC,IAAKR,EAAeS,QACpBC,GAAIV,EAAeS,QAInBE,GAAIX,EAAeY,WAEnB,IAAKZ,EAAea,WACpB,KAAMb,EAAea,WACrB,KAAMb,EAAea,WACrB,KAAMb,EAAea,WACrB,KAAMb,EAAea,WACrB,KAAMb,EAAea,WACrB,KAAMb,EAAea,YAYVC,EAAmE,CAC9E,IAAK,SAACC,EAAGC,GAAM,OAAAC,EAAoBF,EAAGC,EAAG,IAAI,EAC7C,IAAK,SAACD,EAAGC,GAAM,OAAAC,EAAoBF,EAAGC,EAAG,IAAI,EAC7C,IAAK,SAACD,EAAGC,GAAM,OAAAC,EAAoBF,EAAGC,EAAG,IAAI,EAC7C,IAAK,SAACD,EAAGC,GAAM,OAAAC,EAAoBF,EAAGC,EAAG,IAAI,EAC7C,IAAK,SAACD,EAAGC,GAAM,OAAAC,EAAoBF,EAAGC,EAAG,IAAI,EAC7C,KAAM,SAACD,EAAGC,GAAM,OAAAC,EAAoBF,EAAGC,EAAG,KAAK,EAC/C,KAAM,SAACD,EAAGC,GAAM,OAAAC,EAAoBF,EAAGC,EAAG,KAAK,EAE/C,IAAK,SAACD,EAAGC,GAAM,OAAAE,EAAqBH,EAAGC,EAAG,IAAI,EAC9C,KAAM,SAACD,EAAGC,GAAM,OAAAE,EAAqBH,EAAGC,EAAG,KAAK,EAChD,IAAK,SAACD,EAAGC,GAAM,OAAAE,EAAqBH,EAAGC,EAAG,IAAI,EAC9C,KAAM,SAACD,EAAGC,GAAM,OAAAE,EAAqBH,EAAGC,EAAG,KAAK,EAChD,KAAM,SAACD,EAAGC,GAAM,OAAAE,EAAqBH,EAAGC,EAAG,KAAK,EAChD,KAAM,SAACD,EAAGC,GAAM,OAAAE,EAAqBH,EAAGC,EAAG,KAAK,EAChD,KAAM,SAACD,EAAGC,GAAM,OAAAE,EAAqBH,EAAGC,EAAG,KAAK,EAEhDR,IAAK,SAACO,EAAGC,GAAM,OAAAG,EAAiBJ,EAAGC,EAAG,MAAM,EAC5CN,GAAI,SAACK,EAAGC,GAAM,OAAAG,EAAiBJ,EAAGC,EAAG,KAAK,EAI1CL,GAAI,SAACI,EAAGC,GAAM,OAGhB,SAA6BD,EAAcC,EAAcI,GACvD,GAAiB,iBAANL,EACT,OAAQA,EAAaM,SAASC,OAAON,IAGvC,GAAIO,MAAMC,QAAQT,GAChB,OAAQA,EAAgBM,SAASL,GAGnC,MAAM,IAAIjB,MAAM,6BAAsBqB,EAAE,KAC1C,CAbgBK,CAAoBV,EAAGC,EAAG,KAAK,GAe/C,SAASG,EAAiBJ,EAAcC,EAAcI,GACpD,OAAQA,GACN,IAAK,MACH,OAAOL,GAAKC,EAEd,IAAK,KACH,OAAOD,GAAKC,EAEhB,MAAM,IAAIjB,MAAM,6BAAsBqB,EAAE,KAC1C,CAEA,SAASF,EAAqBH,EAAcC,EAAcI,GACxD,OAAQA,GACN,IAAK,KACH,OAAOL,IAAMC,EAEf,IAAK,KAGL,IAAK,KACH,OAAOD,IAAMC,EAEf,IAAK,IACH,OAAQD,EAAgBC,EAE1B,IAAK,IACH,OAAQD,EAAgBC,EAE1B,IAAK,KACH,OAAQD,GAAiBC,EAE3B,IAAK,KACH,OAAQD,GAAiBC,EAG7B,MAAM,IAAIjB,MAAM,6BAAsBqB,EAAE,KAC1C,CAEA,SAASH,EAAoBF,EAAcC,EAAcI,GACvD,OAAQA,GACN,IAAK,IAEH,OAAQL,EAAaC,EAEvB,IAAK,IAEH,OAAQD,EAAaC,EAEvB,IAAK,IACH,OAAQD,EAAgBC,EAE1B,IAAK,IACH,OAAQD,EAAgBC,EAE1B,IAAK,IACH,OAAQD,EAAgBC,EAE1B,IAAK,KACH,OAAOU,KAAKC,IAAIZ,EAAaC,GAGjC,MAAM,IAAIjB,MAAM,6BAAsBqB,EAAE,KAC1C,CC3HM,SAAUQ,EAAaC,GAC3B,OAAOA,EAAM,GAAG,EAClB,CAEM,SAAUC,EAAcD,GAC5B,OAAOA,EAAQA,EAAM,GAAK,IAC5B,CAEM,SAAUE,EAAYF,GAC1B,OAAOA,EAAM,GAAGG,SAAS,EAC3B,CAEM,SAAUC,EAAaJ,GAC3B,OAAOA,EAAM,GAAG,EAClB,CAEM,SAAUK,EAAeL,GAC7B,OAAOA,EAAM,GAAG,EAClB,CAUgB,SAAAM,EAAqBC,EAAiBC,GACpD,IAAMC,EAAoB,GAE1B,IAAKF,EAAOG,OACV,MAAO,GAIT,IADA,IAAIC,EAAQ,EACHC,EAAI,EAAGA,EAAIJ,EAAWE,OAAQE,IAAK,CAC1C,IAAMC,EAAML,EAAWI,GACkB,MAArCX,EAAcM,EAAOI,EAAQ,MAC/BA,GAAgB,GAElBF,EAAOK,KAAKP,EAAOQ,MAAMJ,EAAOE,IAChCF,EAAQE,EAAM,CACf,CAMD,MAJyC,MAArCZ,EAAcM,EAAOI,EAAQ,MAC/BA,GAAgB,GAElBF,EAAOK,KAAKP,EAAOQ,MAAMJ,EAAOJ,EAAOG,SAChCD,CACT,CAEgB,SAAAO,EAAYT,EAAiBU,GAC3C,OAAKV,EAAOG,OAILJ,EAAqBC,EADTW,EAAsBX,GAAQ,SAAAY,GAAS,OAAAA,IAAUF,CAAV,KAFjD,EAIX,UAEgBG,EACdb,EACAc,EACAV,QAAA,IAAAA,IAAAA,EAAS,GAET,IAAK,IAAIC,EAAID,EAAOC,EAAIL,EAAOG,OAAQE,IACrC,GAAIb,EAAaQ,EAAOK,MAAQrC,EAAW+C,cAI3C,GAAiC,MAA7BrB,EAAcM,EAAOK,IACvBA,EAAIW,EAAkBhB,EAAQK,EAAG,IAAK,UACjC,GAAiC,MAA7BX,EAAcM,EAAOK,IAC9BA,EAAIW,EAAkBhB,EAAQK,EAAG,IAAK,UACjC,GAAiC,MAA7BX,EAAcM,EAAOK,IAC9BA,EAAIW,EAAkBhB,EAAQK,EAAG,IAAK,UACjC,GAAIS,EAAUpB,EAAcM,EAAOK,KACxC,OAAOA,EAIX,OAAQ,CACV,CA8BgB,SAAAM,EACdX,EACAc,GAIA,IAFA,IAAMG,EAAsB,GAEnBZ,EAAI,EAAGA,EAAIL,EAAOG,OAAQE,IAAK,CACtC,IAAMa,EAASxB,EAAcM,EAAOK,IACtBb,EAAaQ,EAAOK,MAEpBrC,EAAW+C,gBAIV,MAAXG,EACFb,EAAIW,EAAkBhB,EAAQK,EAAG,IAAK,KAClB,MAAXa,EACTb,EAAIW,EAAkBhB,EAAQK,EAAG,IAAK,KAClB,MAAXa,EACTb,EAAIW,EAAkBhB,EAAQK,EAAG,IAAK,KAC7BS,EAAUI,IACnBD,EAAUV,KAAKF,GAElB,CAED,OAAOY,CACT,CAEgB,SAAAE,EACdnB,EACAoB,GAEA,YAFA,IAAAA,IAAAA,EAA2C,MAIvCT,EAAsBX,EAFlBoB,EAE0B,SAAAR,GAAS,OAAA3C,EAAa2C,KAAwBQ,CAArC,EADT,SAAAR,GAAS,YAAqCS,IAArCpD,EAAa2C,IAE1D,CAEA,SAASI,EACPhB,EACAK,EACAiB,EACAC,GAGA,IADA,IAAIC,EAAgB,EACb9B,EAAcM,IAASK,MAAQkB,GAA+B,IAAlBC,GAAqB,CACtE,GAAInB,EAAI,GAAKL,EAAOG,OAClB,MAAM,IAAIxC,MAAM,mBAAY4D,EAAS,iBAGvC,IAAME,EAAa/B,EAAcM,EAAOK,IACpCoB,IAAeH,GACjBE,IAEEC,IAAeF,GACjBC,GAEH,CACD,OAAOnB,CACT,EA/MA,SAAYrC,GACVA,EAAAA,EAAA,WAAA,GAAA,aACAA,EAAAA,EAAA,QAAA,GAAA,UACAA,EAAAA,EAAA,UAAA,GAAA,YACAA,EAAAA,EAAA,SAAA,GAAA,WACAA,EAAAA,EAAA,cAAA,GAAA,gBACAA,EAAAA,EAAA,YAAA,GAAA,cACAA,EAAAA,EAAA,cAAA,GAAA,gBACAA,EAAAA,EAAA,YAAA,GAAA,cACAA,EAAAA,EAAA,QAAA,GAAA,SACD,CAVD,CAAYA,IAAAA,EAUX,CAAA,ICyCD,IAAA0D,EAEE,SAAmBC,GAAArE,KAAIqE,KAAJA,EADnBrE,KAAGsE,SAA4BP,CACS,EAG1CQ,EAAA,SAAA1E,GACE,SAAA0E,EAAmBC,EAAwBC,EAAwBH,GAAnE,IACEvE,EAAAF,EAAA6E,KAAA1E,KAAM,WAEPA,YAHkBD,EAAMyE,OAANA,EAAwBzE,EAAM0E,OAANA,EAAwB1E,EAAGuE,IAAHA,EAEjEvE,EAAKuE,IAAMA,GACZ,CACH,OALgClE,EAAOmE,EAAA1E,GAKtC0E,CAAD,CALA,CAAgCH,GAOhCO,EAAA,SAAA9E,GAGE,SAAA8E,EAAYxC,GAAZ,IACEpC,EAAAF,EAAA6E,KAAA1E,KAAM,UAGPA,YAFCD,EAAKuD,MAAQlB,EAAcD,GAC3BpC,EAAKuE,IAAMjC,EAAYF,IACxB,CACH,OAR+B/B,EAAOuE,EAAA9E,GAQrC8E,CAAD,CARA,CAA+BP,GAU/BQ,EAAA,SAAA/E,GACE,SAAmB+E,EAAAC,EAAwBP,GAA3C,IACEvE,EAAAF,EAAA6E,KAAA1E,KAAM,YAEPA,YAHkBD,EAAO8E,QAAPA,EAAwB9E,EAAGuE,IAAHA,EAEzCvE,EAAKuE,IAAMA,GACZ,CACH,OALiClE,EAAOwE,EAAA/E,GAKvC+E,CAAD,CALA,CAAiCR,GAOjCU,EAAA,SAAAjF,GACE,SAAmBiF,EAAAC,EAAqDT,QAArD,IAAAS,IAAAA,OAA4ChB,GAA/D,IACEhE,EAAAF,EAAA6E,KAAA1E,KAAM,WAEPA,YAHkBD,EAAWgF,YAAXA,EAAqDhF,EAAGuE,IAAHA,EAEtEvE,EAAKuE,IAAMA,GACZ,CACH,OALgClE,EAAO0E,EAAAjF,GAKtCiF,CAAD,CALA,CAAgCV,GAOhCY,EAAA,SAAAnF,GACE,SAAAmF,EAAmBC,EAA0BC,EAAiCZ,GAA9E,IACEvE,EAAAF,EAAA6E,KAAA1E,KAAM,UAEPA,YAHkBD,EAASkF,UAATA,EAA0BlF,EAAemF,gBAAfA,EAAiCnF,EAAGuE,IAAHA,EAE5EvE,EAAKuE,IAAMA,GACZ,CACH,OAL+BlE,EAAO4E,EAAAnF,GAKrCmF,CAAD,CALA,CAA+BZ,GAO/Be,EAAA,SAAAtF,GACE,SAAAsF,IACE,OAAAtF,EAAA6E,KAAA1E,KAAM,aAAWA,IAClB,CACH,OAJkCI,EAAO+E,EAAAtF,GAIxCsF,CAAD,CAJA,CAAkCf,GAMlCgB,EAAA,SAAAvF,GACE,SAAAuF,IACE,OAAAvF,EAAA6E,KAAA1E,KAAM,UAAQA,IACf,CACH,OAJ+BI,EAAOgF,EAAAvF,GAIrCuF,CAAD,CAJA,CAA+BhB,IAM/B,SAAAvE,GAEE,SAAAwF,EAAYlD,GAAZ,IACEpC,EAAAF,EAAA6E,KAAA1E,KAAM,iBAGPA,YAFCD,EAAKZ,KAAOgD,EAAM,GAClBpC,EAAKuE,IAAMjC,EAAYF,IACxB,CANmC/B,EAAOiF,EAAAxF,EAA7C,CAAA,CAAsCuE,GAStC,IAAAkB,EAAA,SAAAzF,GAGE,SAAAyF,EAAmBnG,EAAqBoG,EAAqCjB,GAA7E,IACEvE,EAAAF,EAAA6E,KAAA1E,KAAM,aAEPA,YAHkBD,EAAIZ,KAAJA,EAAqBY,EAAUwF,WAAVA,EAAqCxF,EAAGuE,IAAHA,EAFtEvE,EAAYyF,kBAAwBzB,EAIzChE,EAAKuE,IAAMA,GACZ,CACH,OAPsClE,EAAOkF,EAAAzF,GAO5CyF,CAAD,CAPA,CAAsClB,GAStCqB,EAAA,SAAA5F,GACE,SAAA4F,EACSC,EACAC,EACAC,EACAtB,GAJT,IAMEvE,EAAAF,EAAA6E,KAAA1E,KAAM,YAEPA,YAPQD,EAAO2F,QAAPA,EACA3F,EAAM4F,OAANA,EACA5F,EAAO6F,QAAPA,EACA7F,EAAGuE,IAAHA,EAGPvE,EAAKuE,IAAMA,GACZ,CACH,OAVqClE,EAAOqF,EAAA5F,GAU3C4F,CAAD,CAVA,CAAqCrB,GAYrCyB,EAAA,SAAAhG,GACE,SAAAgG,EAAmBH,EAA0BC,EAAyBrB,GAAtE,IACEvE,EAAAF,EAAA6E,KAAA1E,KAAM,iBAEPA,YAHkBD,EAAO2F,QAAPA,EAA0B3F,EAAM4F,OAANA,EAAyB5F,EAAGuE,IAAHA,EAEpEvE,EAAKuE,IAAMA,GACZ,CACH,OALsClE,EAAOyF,EAAAhG,GAK5CgG,CAAD,CALA,CAAsCzB,GAOtC0B,EAAA,SAAAjG,GACE,SAAAiG,EACSC,EACAC,EACA1B,GAHT,IAKEvE,EAAAF,EAAA6E,KAAA1E,KAAM,SAEPA,YANQD,EAAagG,cAAbA,EACAhG,EAAQiG,SAARA,EACAjG,EAAGuE,IAAHA,EAGPvE,EAAKuE,IAAMA,GACZ,CACH,OAT8BlE,EAAO0F,EAAAjG,GASpCiG,CAAD,CATA,CAA8B1B,GAW9B6B,EAAA,SAAApG,GACE,SACSoG,EAAAF,EACAG,EACAC,EACAC,EACA9B,QAFA,IAAA6B,IAAAA,OAAyCpC,QACzC,IAAAqC,IAAAA,OAA2CrC,GAJpD,IAOEhE,EAAAF,EAAA6E,KAAA1E,KAAM,OAEPA,YARQD,EAAagG,cAAbA,EACAhG,EAAMmG,OAANA,EACAnG,EAAKoG,MAALA,EACApG,EAAQqG,SAARA,EACArG,EAAGuE,IAAHA,EAGPvE,EAAKuE,IAAMA,GACZ,CACH,OAX4BlE,EAAO6F,EAAApG,GAWlCoG,CAAD,CAXA,CAA4B7B,GAa5BiC,EAAA,SAAAxG,GACE,SACSwG,EAAAC,EACAC,EACAH,EACAI,EAEAlC,GANT,IAQEvE,EAAAF,EAAA6E,KAAA1E,KAAM,cAEPA,YATQD,EAAOuG,QAAPA,EACAvG,EAAMwG,OAANA,EACAxG,EAAQqG,SAARA,EACArG,EAAWyG,YAAXA,EAEAzG,EAAGuE,IAAHA,EAGPvE,EAAKuE,IAAMA,GACZ,CACH,OAZmClE,EAAOiG,EAAAxG,GAYzCwG,CAAD,CAZA,CAAmCjC,GAcnCqC,EAAA,SAAA5G,GACE,SAAA4G,EACSC,EACAC,EACAC,EACAtC,GAJT,IAMEvE,EAAAF,EAAA6E,KAAA1E,KAAM,QAEPA,YAPQD,EAAW2G,YAAXA,EACA3G,EAAW4G,YAAXA,EACA5G,EAAI6G,KAAJA,EACA7G,EAAGuE,IAAHA,EAGPvE,EAAKuE,IAAMA,GACZ,CACH,OAV6BlE,EAAOqG,EAAA5G,GAUnC4G,CAAD,CAVA,CAA6BrC,GAY7ByC,EAAA,SAAAhH,GACE,SAAAgH,EAAmBC,EAA2BF,EAAwBtC,GAAtE,IACEvE,EAAAF,EAAA6E,KAAA1E,KAAM,UAEPA,YAHkBD,EAAS+G,UAATA,EAA2B/G,EAAI6G,KAAJA,EAAwB7G,EAAGuE,IAAHA,EAEpEvE,EAAKuE,IAAMA,GACZ,CACH,OAL+BlE,EAAOyG,EAAAhH,GAKrCgH,CAAD,CALA,CAA+BzC,GAO/B2C,EAAA,SAAAlH,GACE,SAAAkH,EACSvH,EACAoH,EACAI,EACA1C,QADA,IAAA0C,IAAAA,OAA0CjD,GAHnD,IAMEhE,EAAAF,EAAA6E,KAAA1E,KAAM,WAEPA,YAPQD,EAAMP,OAANA,EACAO,EAAI6G,KAAJA,EACA7G,EAAKiH,MAALA,EACAjH,EAAGuE,IAAHA,EAGPvE,EAAKuE,IAAMA,GACZ,CACH,OAVgClE,EAAO2G,EAAAlH,GAUtCkH,CAAD,CAVA,CAAgC3C,GAYhC6C,EAAA,SAAApH,GAIE,SAAYoH,EAAA9E,EAAcqD,QAAA,IAAAA,IAAAA,OAA6CzB,GAAvE,IACEhE,EAAAF,EAAA6E,KAAA1E,KAAM,iBAIPA,YAPDD,EAAYyF,kBAAwBzB,EAIlChE,EAAKZ,KAAOgD,EAAM,GAClBpC,EAAKyF,aAAeA,EACpBzF,EAAKuE,IAAMjC,EAAYF,IACxB,CACH,OAVsC/B,EAAO6G,EAAApH,GAU5CoH,CAAD,CAVA,CAAsC7C,GAYtC8C,EAAA,SAAArH,GACE,SAAmBqH,EAAAC,EAA8B7C,GAAjD,IACEvE,EAAAF,EAAA6E,KAAA1E,KAAM,kBAEPA,YAHkBD,EAAUoH,WAAVA,EAA8BpH,EAAGuE,IAAHA,EAE/CvE,EAAKuE,IAAMA,GACZ,CACH,OALuClE,EAAO8G,EAAArH,GAK7CqH,CAAD,CALA,CAAuC9C,GAOvCgD,EAAA,SAAAvH,GACE,SAAmBuH,EAAAC,EAAoC/C,GAAvD,IACEvE,EAAAF,EAAA6E,KAAA1E,KAAM,iBAEPA,YAHkBD,EAAKsH,MAALA,EAAoCtH,EAAGuE,IAAHA,EAErDvE,EAAKuE,IAAMA,GACZ,CACH,OALsClE,EAAOgH,EAAAvH,GAK5CuH,CAAD,CALA,CAAsChD,GAOtCkD,EAAA,SAAAzH,GACE,SAAmByH,EAAAC,EAAyBjD,GAA5C,IACEvE,EAAAF,EAAA6E,KAAA1E,KAAM,gBAEPA,YAHkBD,EAAKwH,MAALA,EAAyBxH,EAAGuE,IAAHA,EAE1CvE,EAAKuE,IAAMA,GACZ,CACH,OALqClE,EAAOkH,EAAAzH,GAK3CyH,CAAD,CALA,CAAqClD,GAOrCoD,EAAA,SAAA3H,GACE,SAAA2H,EACSC,EACAjC,EACAlB,QADA,IAAAkB,IAAAA,OAA6CzB,GAFtD,IAKEhE,EAAAF,EAAA6E,KAAA1E,KAAM,yBAEPA,YANQD,EAAW0H,YAAXA,EACA1H,EAAYyF,aAAZA,EACAzF,EAAGuE,IAAHA,EAGPvE,EAAKuE,IAAMA,GACZ,CACH,OAT8ClE,EAAOoH,EAAA3H,GASpD2H,CAAD,CATA,CAA8CpD,GAgB9CsD,EAAA,SAAA7H,GACE,SAAmB6H,EAAAH,EAAiCjD,GAApD,IACEvE,EAAAF,EAAA6E,KAAA1E,KAAM,cAEPA,YAHkBD,EAAKwH,MAALA,EAAiCxH,EAAGuE,IAAHA,EAElDvE,EAAKuE,IAAMA,GACZ,CACH,OALmClE,EAAOsH,EAAA7H,GAKzC6H,CAAD,CALA,CAAmCtD,GAOnCuD,EAAA,SAAA9H,GACE,SAAA8H,EACSC,EACAlG,EACAmG,EACAvD,GAJT,IAMEvE,EAAAF,EAAA6E,KAAA1E,KAAM,UAEPA,YAPQD,EAAI6H,KAAJA,EACA7H,EAAE2B,GAAFA,EACA3B,EAAK8H,MAALA,EACA9H,EAAGuE,IAAHA,EAGPvE,EAAKuE,IAAMA,GACZ,CACH,OAV+BlE,EAAOuH,EAAA9H,GAUrC8H,CAAD,CAVA,CAA+BvD,GC/PzB,SAAU0D,GAAaC,GAC3B,MAAO,CACLC,WAAYD,EAAQC,WACpBC,WAAYF,EAAQE,WAAWC,QAE/BC,kBAAmBJ,EAAQI,kBAE/B,CAEA,IAAAC,GAAA,WAGE,SAAAA,EAAYC,GAFKrI,KAAKsI,MAA4B,GAGhDtI,KAAKsI,MAAaC,EAAA,CAAA,EAAAF,EACnB,CAgBH,OAdED,EAAAjI,UAAAqI,SAAA,WACE,OAAOxI,KAAKsI,OAGdF,EAAAjI,UAAA+H,MAAA,WACE,OAAO,IAAIE,EAAMpI,KAAKsI,QAExBF,EAAAjI,UAAAsI,IAAA,SAAIC,EAAapF,GACftD,KAAKsI,MAAMI,GAAOpF,GAGpB8E,EAAGjI,UAAAwI,IAAH,SAAID,GACF,OAAO1I,KAAKsI,MAAMI,IAErBN,CAAD,ICfAQ,GAAA,WAAA,SAAAA,IAudC,CAAD,OAtdEA,EAAAzI,UAAA0I,UAAA,SAAUC,EAAeC,GAGvB,IAHF,IAwEChJ,EAAAC,KAvEKgJ,EAAa,gBAENC,GACT,IAAMC,EAAUD,EAGCF,EAAad,WAErBQ,IAAIS,EAAQxD,QAAQvG,MAAM,eAAC,IAAkBgK,EAAA,GAAAC,EAAA,EAAlBA,EAAkBC,UAAAxG,OAAlBuG,IAAAD,EAAkBC,GAAAC,UAAAD,GACpD,OAAArJ,EAAKuJ,gBAALC,MAAAxJ,KAAqBmJ,EAASH,GAAiBI,GAAI,GAAnD,KAP+BC,EAAA,EAAhBI,GAAAV,aAAG,EAAHA,EAAKW,QAAS,GAAdL,EAAAI,EAAA3G,OAAAuG,IAAgB,GAAxBH,EAAIO,EAAAJ,GASd,CAED,IAAK,IAAIrG,EAAI,EAAGA,EAAI+F,EAAIlC,KAAK/D,OAAQE,IAAK,CACxC,IAAMkG,EAAOH,EAAIlC,KAAK7D,GACtB,GAAIgG,EAAaZ,kBAAkBuB,OAAQ,CACzC,IAAMpF,EAAM2E,EAAK3E,KAAO,GAMxB,OAJKyE,EAAaZ,kBAAkBxI,UAClCoJ,EAAaZ,kBAAkBxI,QAAU,cAAcC,OAAAmJ,EAAaf,WAAU,MAAApI,OAAK0E,EAAI,GAAO,MAAA1E,OAAA0E,EAAI,KAG7FyE,EAAaZ,kBAAkBxI,OACvC,CAED,GAAkB,YAAdsJ,EAAK5E,KAAT,CAGA,GAAkB,WAAd4E,EAAK5E,KAEP,MAAM,IAAIhE,MAAM,qEAElB,IAGE,GAFA2I,EAAahJ,KAAK2J,SAASV,EAAMF,GAE7BA,EAAaa,aAAc,CAC7B,IAAMC,EAAMd,EAAae,aAOzB,MAJgB,QAAZhB,EAAIzE,MAA8B,UAAZyE,EAAIzE,OAC5B0E,EAAaa,cAAe,EAC5Bb,EAAae,aAAe,MAEvBD,CACR,CAED,GAAId,EAAagB,eACf,MAEF,GAAIhB,EAAaiB,YACf,KAiBH,CAfC,MAAOC,GACD3F,EAAM2E,EAAK3E,IAAM2E,EAAK3E,IAAM,CAAC,EAAG,GACtC,MAAI2F,aAAexJ,GAERwJ,aAAezJ,EADlByJ,EAIA,IAAIzJ,EACRuI,EAAaf,WACb1D,EAAI,GACJA,EAAI,GAEH2F,EAAYtK,SAAWsK,EAG7B,CAxCA,CAyCF,CAED,OAAOjB,GAGTJ,EAAAzI,UAAAmJ,gBAAA,SAAgBJ,EAAsBnB,aAAyCoB,EAAA,GAAAC,EAAA,EAAlBA,EAAkBC,UAAAxG,OAAlBuG,IAAAD,EAAkBC,EAAA,GAAAC,UAAAD,GAC7E,IAAMN,EAAM7I,OAAOiK,OAAO,CAAA,EAAIhB,EAAQxD,SACtCoD,EAAIzE,KAAO,OAKX,IAHA,IAAM0E,EAAejB,GAAaC,GAGzBhF,EAAI,EAAGA,GAAkB,QAAdyG,EAAAN,EAAQvD,cAAM,IAAA6D,OAAA,EAAAA,EAAE3G,QAAaE,IAAK,CACpD,IAAMoH,GAAWhB,aAAI,EAAJA,EAAMtG,QAASE,EAAIoG,EAAKpG,GAAK,KAC9CgG,EAAad,WAAWQ,IAAIS,EAAQvD,OAAO5C,GAAIoH,EAChD,CAED,OAAOnK,KAAK6I,UAAUC,EAAKC,IAGrBH,EAAAzI,UAAAiK,eAAR,SACEC,EACAC,EAEAhG,GAEA,OAAO+F,EAAQd,WAAA,EAAAe,IAGT1B,EAAAzI,UAAAwJ,SAAR,SAAiBV,EAAeF,GAAhC,kBA+TChJ,EAAAC,KA9TC,GAAkB,WAAdiJ,EAAK5E,KAEP,OAAO,KAGT,GAAkB,YAAd4E,EAAK5E,KACP,OAAO,KAGT,GAAkB,OAAd4E,EAAK5E,KAAT,CAkCA,GAAkB,UAAd4E,EAAK5E,KAAkB,CACzB,IAEM4F,EAFAM,EAAYtB,EACZuB,EAAexK,KAAK2J,SAASY,EAAUrF,gBAAiB6D,GAQ9D,MAPY,IAAItI,EACdsI,EAAaf,WACbuC,EAAUjG,IAAI,GACdiG,EAAUjG,IAAI,GACdiG,EAAUtF,UACVuF,EAGH,CAED,GAAkB,cAAdvB,EAAK5E,KAAT,CAwDA,GAAkB,WAAd4E,EAAK5E,KAAmB,CAC1B,IAAMoG,EAAaxB,EAMnB,OALAF,EAAaa,cAAe,EAC5Bb,EAAae,aAAeW,EAAW1F,YACnC/E,KAAK2J,SAASc,EAAW1F,YAAagE,GACtC,KAEGA,EAAae,YACrB,CAED,GAAkB,aAAdb,EAAK5E,KAKT,GAAkB,UAAd4E,EAAK5E,KAKT,GAAkB,QAAd4E,EAAK5E,KA2BT,GAAkB,UAAd4E,EAAK5E,KAAT,CAuBA,GAAkB,UAAd4E,EAAK5E,KACP,OAAQ4E,EAAmB3F,MAG7B,GAAkB,iBAAd2F,EAAK5E,KAAyB,CAChC,IAAMqG,EAAQzB,EAA0B9J,KAElCmE,EAAQyF,EAAad,WAAWU,IAAKM,EAA0B9J,MACrE,QAAc4E,IAAVT,EACF,KAAqC,MAAjCoH,EAAKC,OAAOD,EAAK7H,OAAS,GACtB,IAAIxC,MAAM,8BAEV,IAAIA,MAAM,oBAAaqK,EAAI,sBAGrC,OAAOpH,CACR,CAED,GAAkB,UAAd2F,EAAK5E,KAAkB,CACzB,IAAMuG,EAAY3B,EACZrB,EAAO5H,KAAK2J,SAASiB,EAAUhD,KAAMmB,GACrClB,EAAQ7H,KAAK2J,SAASiB,EAAU/C,MAAOkB,GAC7C,OAAO3H,EAAewJ,EAAUlJ,IAAIkG,EAAmBC,EACxD,CAED,GAAkB,cAAdoB,EAAK5E,KAAsB,CAK7B,IAJA,IAAMwG,EAAgB5B,EAClBjG,EAAM,EACN8H,GAAmB,EAEhB9H,EAAM6H,EAActD,MAAM1E,QAAQ,CACvC,IAAMkI,EAAKF,EAActD,MAAMvE,KAI/B,GAFA8H,EAAU9K,KAAK2J,SAASoB,EAAG9B,KAAMF,GAEnB,QAAVgC,EAAGrJ,KAAiBoJ,EACtB,OAAO,EAET,GAAc,OAAVC,EAAGrJ,IAAeoJ,EACpB,OAAOA,CAEV,CAED,OAAOA,CACR,CAED,GAAkB,iBAAd7B,EAAK5E,KAAyB,CAChC,IAAM2G,EAAe/B,EAErB,OAAO,eAAC,IAAkBE,EAAA,GAAAC,EAAA,EAAlBA,EAAkBC,UAAAxG,OAAlBuG,IAAAD,EAAkBC,GAAAC,UAAAD,GACxB,OAAArJ,EAAKuJ,gBAALC,MAAAxJ,KAAqBiL,EAAcjC,GAAiBI,GAAI,GAAxD,CACH,CAED,GAAkB,aAAdF,EAAK5E,KAAqB,CAC5B,IAAM4G,EAAehC,EACfoB,EAAOtB,EAAad,WAAWU,IAAIsC,EAAa9L,MAGtD,GAAoB,mBAATkL,EACT,MAAMhK,MAAM,IAAIT,OAAAqL,EAAa9L,KAAI,wCAGnC,IAAM+L,GAA+B,QAAzBC,EAAAF,EAAa1F,kBAAY,IAAA4F,OAAA,EAAAA,EAAAC,KAAI,SAAAC,GAAK,OAAAtL,EAAK4J,SAAS0B,EAAGtC,QAAkB,GAEjF,OAAO/I,KAAKoK,eAAeC,EAAMa,EAAK,CACpClD,WAAYe,EAAaf,WACzBvI,KAAMwL,EAAa3G,IAAI,GACvB5E,OAAQuL,EAAa3G,IAAI,IAE5B,CAED,GAAkB,WAAd2E,EAAK5E,KAAmB,CAC1B,IAAMiH,EAAarC,EAEnB,GAA+B,iBAA3BqC,EAAW9G,OAAOH,KAAyB,CAC7C,IAAMkH,EAAOD,EAAW9G,OACxBuE,EAAad,WAAWQ,IAAI8C,EAAKpM,KAAMa,KAAK2J,SAAS2B,EAAW7G,OAAQsE,GACzE,MAAM,GAA+B,kBAA3BuC,EAAW9G,OAAOH,KAA0B,CACrD,IAAMmH,EAAaF,EAAW9G,OAIxBiH,EAAmB,IAAIvE,EAC3BsE,EAAWrE,WAAWjE,MAAM,EAAGsI,EAAWrE,WAAWtE,OAAS,GAC9D2I,EAAWlH,KAEPoH,EAAe1L,KAAK2J,SAAS8B,EAAkB1C,GAK/C4C,EAAgBH,EAAWrE,WAAWqE,EAAWrE,WAAWtE,OAAS,GAEvE+I,EAAmB,GACvB,GAA2B,iBAAvBD,EAActH,KAChBuH,EAAoBD,EAAmCxM,SAClD,IAA2B,yBAAvBwM,EAActH,KAMvB,MAAMhE,MAAM,wDALZuL,EAAmB5L,KAAK2J,SACrBgC,EAA2ClE,YAC5CsB,EAIH,CAED2C,EAAaE,GAAoB5L,KAAK2J,SAAS2B,EAAW7G,OAAQsE,EACnE,CAED,OAAO,IACR,CAED,GAAkB,kBAAdE,EAAK5E,KACP,OAAOrE,KAAK6L,yBAAyB5C,EAA2BF,GAGlE,GAAkB,iBAAdE,EAAK5E,KAAyB,CAIhC,IAHA,IACMyH,EAAM,CAAA,EAEI1C,EAAA,EAAA2C,EAHS9C,EAGQ5B,MAAjB+B,EAAA2C,EAAAlJ,OAAAuG,IAAwB,CAAnC,IAAM4C,EAACD,EAAA3C,GACV0C,EAAI9L,KAAK2J,SAASqC,EAAE7M,KAAM4J,IAA2B/I,KAAK2J,SAASqC,EAAE1I,MAAOyF,EAC7E,CAED,OAAO+C,CACR,CAED,GAAkB,gBAAd7C,EAAK5E,KAAwB,CAI/B,IAHA,IACMwF,EAAM,GAEOoC,EAAA,EAAAC,EAHDjD,EAGW1B,MAAV0E,EAAAC,EAAArJ,OAAAoJ,IAAiB,CAAzBE,EAAID,EAAAD,GACbpC,EAAI5G,KAAKjD,KAAK2J,SAASwC,EAAMpD,GAC9B,CAED,OAAOc,CACR,CAzIA,KArBD,CAGE,IAFA,IAAMuC,EAAYnD,EAEXjJ,KAAK2J,SAASyC,EAAUtF,UAAWiC,KACxC/I,KAAK6I,UACH,CAAE1J,KAAM4J,EAAaf,WAAY3D,KAAM,QAASuC,KAAMwF,EAAUxF,MAChEmC,GAGEA,EAAagB,iBACfhB,EAAagB,gBAAiB,IAE5BhB,EAAaiB,eAIfjB,EAAaiB,cACfjB,EAAaiB,aAAc,EAI9B,KAhDD,CACE,IAAMqC,EAAUpD,EAEVqD,EAAQtM,KAAK2J,SAAS0C,EAAQ3F,YAAaqC,GAEjD,IAAShG,GAAI,EAAGA,GAAIuJ,EAAMzJ,OAAQE,KAAK,CACrC,IAAMoJ,EAAOG,EAAMvJ,IAUnB,GARAgG,EAAad,WAAWQ,IAAI4D,EAAQ1F,YAAawF,GACjDnM,KAAK6I,UACH,CAAE1J,KAAM4J,EAAaf,WAAY3D,KAAM,MAAOuC,KAAMyF,EAAQzF,MAC5DmC,GAEEA,EAAagB,iBACfhB,EAAagB,gBAAiB,GAE5BhB,EAAaiB,YACf,KAEH,CAEGjB,EAAaiB,cACfjB,EAAaiB,aAAc,EAG9B,MA7BCjB,EAAaiB,aAAc,OAL3BjB,EAAagB,gBAAiB,CAb/B,KAtDD,CACE,IAAMwC,EAAUtD,EAChB,IACEjJ,KAAK6I,UACH,CAAE1J,KAAM4J,EAAaf,WAAY3D,KAAM,WAAYuC,KAAM2F,EAAQjG,SACjEyC,IAGoB,QAAlByD,EAAAD,EAAQnG,gBAAU,IAAAoG,OAAA,EAAAA,EAAA3J,SACpB7C,KAAK6I,UACH,CAAE1J,KAAM4J,EAAaf,WAAY3D,KAAM,WAAYuC,KAAM2F,EAAQnG,UACjE2C,EAwCL,CArCC,MAAOkB,GACP,IAAMwC,EAAOxC,aAAexJ,EAAawJ,EAAkB9K,YAAc8K,EACnEtK,EACJsK,aAAexJ,EACVwJ,EAAkBtK,QAEE,QAArB+M,EAACzC,aAAG,EAAHA,EAAatK,eAAO,IAAA+M,EAAAA,EAAI9K,OAAOqI,GAChCjC,EAAaiC,aAAexJ,EAAawJ,EAAkBzK,OAAS,EACpEC,EAAOwK,aAAexJ,EAAawJ,EAAkBxK,KAAO,EAC5DC,GAASuK,aAAexJ,EAAawJ,EAAkBvK,OAAS,EAEhEiN,GAAaJ,EAAQhG,OAAO,GAC5BqG,GAAYD,GAAW/F,KACvBiG,GAAM9D,EACZ8D,GAAI5E,WAAWQ,KAAoB,QAAhBqE,EAAAH,GAAWpN,aAAK,IAAAuN,OAAA,EAAAA,EAAEC,QAAS,QAAS,CACrD5N,KAAIsN,EACJ9M,QAAOA,EACPF,KAAIA,EACJC,OAAMA,GACNsI,WAAUA,IAEZhI,KAAK6I,UACH,CAAE1J,KAAM4J,EAAaf,WAAY3D,KAAM,WAAYuC,KAAMgG,IACzDC,IAEFA,GAAI5E,WAAWQ,aAAIuE,EAAAL,GAAWpN,4BAAOwN,QAAS,QAAS,KACxD,CAAS,SACiB,QAArBE,EAAAV,EAAQ/F,mBAAa,IAAAyG,OAAA,EAAAA,EAAApK,SACvB7C,KAAK6I,UACH,CACE1J,KAAM4J,EAAaf,WACnB3D,KAAM,WACNuC,KAAM2F,EAAQ/F,aAEhBuC,EAGL,CAGF,CArEA,KAhCD,CACE,IAAMmE,GAASjE,EACXkE,IAAS,EACb,GAAInN,KAAK2J,SAASuD,GAAOnH,cAAegD,GACtC/I,KAAK6I,UACH,CAAE1J,KAAM4J,EAAaf,WAAY3D,KAAM,KAAMuC,KAAMsG,GAAOhH,QAC1D6C,GAEFoE,IAAS,OACJ,GAAgB,UAAZD,GAAO/G,aAAK,IAAAqD,OAAA,EAAAA,EAAE3G,OACvB,IAAK,IAAIE,GAAI,EAAGA,GAAImK,GAAO/G,MAAMtD,OAAQE,KAAK,CAC5C,IAAMqK,GAAWF,GAAO/G,MAAMpD,IAE9B,GAAI/C,KAAK2J,SAASyD,GAASrH,cAAegD,GAAe,CACvD/I,KAAK6I,UACH,CAAE1J,KAAM4J,EAAaf,WAAY3D,KAAM,KAAMuC,KAAMwG,GAASpH,UAC5D+C,GAEFoE,IAAS,EACT,KACD,CACF,CAGCA,IAAUD,GAAO9G,UACnBpG,KAAK6I,UACH,CAAE1J,KAAM4J,EAAaf,WAAY3D,KAAM,KAAMuC,KAAMsG,GAAO9G,UAC1D2C,EAKL,GAuRKH,EAAAzI,UAAA0L,yBAAR,SAAiCwB,EAA2BtE,GAI1D,IAFA,IAAIuE,EAActN,KAAK2J,SAAS0D,EAAOlG,WAAW,GAAI4B,GAE7ChG,EAAI,EAAGA,EAAIsK,EAAOlG,WAAWtE,OAAQE,IAAK,CACjD,IAAMwK,EAAaF,EAAOlG,WAAWpE,GAMrC,GAJKsK,EAAOlG,WAAWpE,EAAI,GAAiCyC,eAAiB8H,IAC3EA,EAAc,CAAA,GAGQ,iBAApBC,EAAWlJ,KACbiJ,EAAcA,EAAaC,EAAgCpO,WACtD,GAAwB,yBAApBoO,EAAWlJ,KAAiC,CACrD,IAAM4E,EAAOsE,EAEbD,EAAcA,EACZtN,KAAK2J,SAASV,EAAKxB,YAAasB,GAEnC,KAAM,IAAwB,aAApBwE,EAAWlJ,KA0BpB,MAAMhE,MAAM,oCAzBZ,IAAM4K,EAAesC,EACflD,EAAOiD,EAAYrC,EAAa9L,MAEtC,GACE,MAACkL,GACAgD,EAAOlG,WAAWpE,EAAI,GAAiCyC,aACxD,CACA8H,EAAc,KACd,QACD,CAED,GAAoB,mBAATjD,EACT,MAAMhK,MAAM,IAAIT,OAAAqL,EAAa9L,KAAI,wCAGnC,IADA,IAAM+L,EAAM,GACiC9B,EAAA,EAA7BI,EAAAyB,EAAa1F,YAAc,GAA3B6D,EAAAI,EAAA3G,OAAAuG,IAA+B,CAA1C,IAAM4C,EAACxC,EAAAJ,GACV8B,EAAIjI,KAAKjD,KAAK2J,SAASqC,EAAGjD,GAC3B,CAEDuE,EAActN,KAAKoK,eAAeC,EAAKmD,KAAKF,GAAcpC,EAAK,CAC7DlD,WAAYe,EAAaf,WACzBvI,KAAMwL,EAAa3G,IAAI,GACvB5E,OAAQuL,EAAa3G,IAAI,IAI5B,CACF,CAED,YAAuBP,IAAhBuJ,EAA4B,KAAOA,GAE7C1E,CAAD,IChdA6E,GAAA,WAAA,SAAAA,IACUzN,KAAA0N,aAA0D,WAChE,OAAAC,QAAQC,OAAO,mCAAf,EACM5N,KAAc6N,eAA8C,WAAM,OAAAF,QAAQC,OAAO,MAkkB1F,CAAD,OA/jBEH,EAAoBtN,UAAA2N,qBAApB,SAAqBJ,GAEnB,OADA1N,KAAK0N,aAAeA,EACb1N,MAGTyN,EAAsBtN,UAAA4N,uBAAtB,SAAuBF,GAErB,OADA7N,KAAK6N,eAAiBA,EACf7N,MAGTyN,EAA2BtN,UAAA6N,4BAA3B,SACEC,GAGA,OADAjO,KAAKiO,oBAAsBA,EACpBjO,MAGHyN,EAAAtN,UAAA+N,eAAN,SAAqBpF,EAAeC,kJAGlC,IAFIC,EAAa,gBAENC,GACT,IAAMC,EAAUD,EAGVkF,EAAWpF,EAAad,WAExBmG,EAAUlF,EAAQtD,QACpB,eAAO,IAAkBuD,EAAA,GAAAC,EAAA,EAAlBA,EAAkBC,UAAAxG,OAAlBuG,IAAAD,EAAkBC,GAAAC,UAAAD,0FACvB,MAAM,CAAA,EAAApJ,KAAKqO,qBAAL9E,MAAAvJ,KAA0BsO,EAAA,CAAApF,EAASH,GAAiBI,GAAK,KAA/D,KAAA,EAAA,MAAA,CAAA,EAAAK,gBAA+D,EACjE,qBAAmBL,EAAA,GAAAC,EAAA,EAAlBA,EAAkBC,UAAAxG,OAAlBuG,IAAAD,EAAkBC,GAAAC,UAAAD,GACjB,OAAAI,EAAA,IAAIZ,IAAYU,gBAAgBC,MAAAC,EAAA8E,EAAA,CAAApF,EAASH,GAAiBI,GAAI,GAA9D,EAENgF,EAAS1F,IAAIS,EAAQxD,QAAQvG,KAAMiP,IAZrChF,EAAA,EAAmBsD,GAAA5D,aAAA,EAAAA,EAAKW,QAAS,GAAdL,EAAAsD,EAAA7J,OAAAuG,IAARH,EAAIyD,EAAAtD,KAAJH,GAeFlG,EAAI,mBAAG,OAAAA,EAAI+F,EAAIlC,KAAK/D,QACrBoG,EAAOH,EAAIlC,KAAK7D,GAClBgG,EAAaZ,kBAAkBuB,QAC3BpF,EAAM2E,EAAK3E,KAAO,GAEnByE,EAAaZ,kBAAkBxI,UAClCoJ,EAAaZ,kBAAkBxI,QAAU,cAAcC,OAAAmJ,EAAaf,WAAU,MAAApI,OAAK0E,EAAI,GAAO,MAAA1E,OAAA0E,EAAI,KAGpG,CAAA,EAAOyE,EAAaZ,kBAAkBxI,UAGtB,YAAdsJ,EAAK5E,KACE,CAAA,EAAA,IAEO,WAAd4E,EAAK5E,KAAiB,CAAA,EAAA,GAIV,UAFRkK,EAAQrP,GADRsP,EAAavF,GACoBzJ,OAAOL,OAE1B,CAAA,EAAA,IACA6N,GAAAF,EAAA2B,MAAKC,MAAY,CAAA,EAAA1O,KAAK6N,eAAeW,EAAWhP,OAAOL,SApB5C,CAAA,EAAA,WAyB7B,OALMwP,EAAY3B,EAAWzD,MAAAuD,EAAA,CAAAG,EAAA2B,SAC7B7F,EAAad,WAAWQ,IACtB+F,EAAWhP,OAAOuN,OAAS/M,KAAK6O,kBAAkBL,EAAWhP,OAAOL,MACpEwP,GAEO,CAAA,EAAA,WACJ,GAAc,eAAVJ,EAET,MAAS,CAAA,EAAA,qBAGX,GAAwC,mBAA7BvO,KAAKiO,oBACd,MAAM,IAAI5N,MAAM,0CAGA,MAAM,CAAA,EAAAL,KAAK0N,aAAac,EAAWhP,OAAOL,cAE5D,OAFM2P,EAAY7B,EAA+C2B,OAC3DG,EAAqB/O,KAAKiO,oBAAoBO,EAAWhP,OAAOL,KAAM2P,GACtE,CAAA,EAAA9O,KAAKkO,eAAeY,EAAWC,WAmBrC,OAnBA9B,EAAA2B,OAEItG,EAAQS,EAAad,WAAWO,YAEf,QAAhBgB,EAAAgF,EAAWxH,aAAK,IAAAwC,OAAA,EAAAA,EAAE3G,UAErByF,EAAQ,CAAA,EACRS,EAAad,WAAWQ,IACtB+F,EAAWhP,OAAOuN,OAAS/M,KAAK6O,kBAAkBL,EAAWhP,OAAOL,MACpEmJ,IAIJtI,KAAKgP,uBACH1G,EACAyG,EACAD,EACkB,QAAlBtC,EAAAgC,EAAWxH,aAAO,IAAAwF,OAAA,EAAAA,EAAApB,KAAI,SAAAY,GAAK,OAAAA,EAAE7M,IAAI,KAE1B,CAAA,EAAA,WAII,8BAAM,CAAA,EAAAa,KAAKiP,cAAchG,EAAMF,WAC5C,OADAC,EAAaiE,SACTlE,EAAaa,cACTC,EAAMd,EAAae,aAET,QAAZhB,EAAIzE,MAA8B,UAAZyE,EAAIzE,OAC5B0E,EAAaa,cAAe,EAC5Bb,EAAae,aAAe,MAE9B,CAAA,EAAOD,IAGLd,EAAagB,gBAGbhB,EAAaiB,YAFT,CAAA,EAAA,kBAOR,iBADM1F,EAAM2E,EAAK3E,IAAM2E,EAAK3E,IAAM,CAAC,EAAG,GAClC4K,aAAezO,GAERyO,aAAe1O,EADlB0O,EAIA,IAAI1O,EACRuI,EAAaf,WACb1D,EAAI,GACJA,EAAI,GAEH4K,EAAYvP,SAAWuP,kBAzFKnM,UA+FrC,KAAA,GAAA,MAAA,CAAA,EAAOiG,SACR,EAEOyE,EAAsBtN,UAAA6O,uBAA9B,SACE1G,EACAyG,EACAD,EACA9H,GAIA,IARF,IAmBCjH,EAAAC,KAbOyJ,EAAQqF,EAAUrF,MAAM0F,QAAO,SAAAC,GAAK,IAAA5F,EAAA,OAACxC,GAASA,EAAMqI,QAAiB,QAAT7F,EAAA4F,EAAE1J,eAAO,IAAA8D,OAAA,EAAAA,EAAErK,OAAS,CAAC,eAE9E4D,GACP,IAAMmG,EAAUO,EAAM1G,GAEhBqL,EAAUlF,EAAQtD,QACpB,eAAO,IAAkBuD,EAAA,GAAAC,EAAA,EAAlBA,EAAkBC,UAAAxG,OAAlBuG,IAAAD,EAAkBC,GAAAC,UAAAD,0FACvB,MAAM,CAAA,EAAApJ,KAAKqO,qBAAL9E,MAAAvJ,KAA0BsO,EAAA,CAAApF,EAAS6F,GAAuB5F,GAAK,KAArE,KAAA,EAAA,MAAA,CAAA,EAAAK,gBAAqE,EACvE,qBAAmBL,EAAA,GAAAC,EAAA,EAAlBA,EAAkBC,UAAAxG,OAAlBuG,IAAAD,EAAkBC,GAAAC,UAAAD,GACjB,OAAAI,EAAA,IAAIZ,IAAYU,gBAAgBC,MAAAC,EAAA8E,EAAA,CAAApF,EAAS6F,GAAuB5F,GAAI,GAApE,EAENb,EAAMY,EAAQxD,QAAQvG,MAAQiP,GATvBrL,EAAI,EAAGA,EAAI0G,EAAM5G,OAAQE,MAAzBA,IAaH0K,EAAiBtN,UAAA0O,kBAAzB,SAA0B1P,GACxB,OAAOA,EAAKmQ,UAAUnQ,EAAKoQ,YAAY,KAAO,EAAGpQ,EAAKoQ,YAAY,OAGtD9B,EAAAtN,UAAAkO,qBAAd,SACEnF,EACAnB,aACkBoB,EAAA,GAAAC,EAAA,EAAlBA,EAAkBC,UAAAxG,OAAlBuG,IAAAD,EAAkBC,EAAA,GAAAC,UAAAD,yGAQlB,KANMN,EAAM7I,OAAOiK,OAAO,CAAE,EAAEhB,EAAQxD,UAClCrB,KAAO,OAEL0E,EAAejB,GAAaC,GAGzBhF,EAAI,EAAGA,GAAkB,UAAdmG,EAAQvD,cAAM,IAAA6D,OAAA,EAAAA,EAAE3G,QAAaE,IACzCoH,GAAWhB,aAAA,EAAAA,EAAMtG,QAASE,EAAIoG,EAAKpG,GAAK,KAC9CgG,EAAad,WAAWQ,IAAIS,EAAQvD,OAAO5C,GAAIoH,GAG1C,MAAM,CAAA,EAAAnK,KAAKkO,eAAepF,EAAKC,IAAtC,KAAA,EAAA,MAAA,CAAA,EAAOyD,gBACR,EAEaiB,EAAAtN,UAAAqP,oBAAd,SACEnF,EACAC,EAEAhG,6FAEO,MAAM,CAAA,EAAA+F,EAAQd,WAAA,EAAAe,IAArB,KAAA,EAAA,MAAA,CAAA,EAAOd,gBACR,EAEaiE,EAAAtN,UAAA8O,cAAd,SAA4BhG,EAAeF,qQACzC,GAAkB,WAAdE,EAAK5E,KACP,MAAM,IAAIhE,MAAM,yCAGlB,MAAkB,YAAd4I,EAAK5E,KACP,CAAA,EAAO,MAGS,OAAd4E,EAAK5E,KAAa,CAAA,EAAA,KACd6I,EAASjE,EACXkE,GAAS,EAEH,CAAA,EAAAnN,KAAKiP,cAAc/B,EAAOnH,cAAegD,YAA/C,OAAA0G,EAAAb,OACI,CAAA,EAAA5O,KAAKkO,eACT,CAAE/O,KAAM4J,EAAaf,WAAY3D,KAAM,KAAMuC,KAAMsG,EAAOhH,QAC1D6C,IAH4D,CAAA,EAAA,iBAC9D0G,EAAAb,OAIAzB,GAAS,4BACA3D,EAAA0D,EAAO/G,4BAAOtD,QAAd,MAAoB,CAAA,EAAA,GACpBE,EAAI,mBAAG,OAAAA,EAAImK,EAAO/G,MAAMtD,QACzBuK,EAAWF,EAAO/G,MAAMpD,GAEpB,CAAA,EAAA/C,KAAKiP,cAAc7B,EAASrH,cAAegD,KAHhB,CAAA,EAAA,UAGjC,OAAA0G,EAAAb,OACI,CAAA,EAAA5O,KAAKkO,eACT,CAAE/O,KAAM4J,EAAaf,WAAY3D,KAAM,KAAMuC,KAAMwG,EAASpH,UAC5D+C,IAH8D,CAAA,EAAA,UAMhE,OALA0G,EAAAb,OAIAzB,GAAS,EACH,CAAA,EAAA,iBAT+BpK,iBAcvC,OAAAoK,GAAUD,EAAO9G,SACb,CAAA,EAAApG,KAAKkO,eACT,CAAE/O,KAAM4J,EAAaf,WAAY3D,KAAM,KAAMuC,KAAMsG,EAAO9G,UAC1D2C,IAHyB,CAAA,EAAA,WAC3B0G,EAAAb,0BAMF,MAAO,CAAA,WAGL,MAAc,UAAd3F,EAAK5E,KAAgB,CAAA,EAAA,KACjBkG,EAAYtB,EACU,CAAA,EAAAjJ,KAAKiP,cAC/B1E,EAAUrF,gBACV6D,aASF,MAXMyB,EAAgBiF,EAAAb,OAIV,IAAInO,EACdsI,EAAaf,WACbuC,EAAUjG,IAAI,GACdiG,EAAUjG,IAAI,GACdiG,EAAUtF,UACVuF,WAKA,GAAc,cAAdvB,EAAK5E,KAAL,MAAyB,CAAA,EAAA,IACrBkI,EAAUtD,qBAEd,kCAAM,CAAA,EAAAjJ,KAAKkO,eACT,CAAE/O,KAAM4J,EAAaf,WAAY3D,KAAM,WAAYuC,KAAM2F,EAAQjG,SACjEyC,YAGE,OALJ0G,EAAAb,QAKoB,QAAhBpC,EAAAD,EAAQnG,gBAAQ,IAAAoG,OAAA,EAAAA,EAAE3J,QACd,CAAA,EAAA7C,KAAKkO,eACT,CAAE/O,KAAM4J,EAAaf,WAAY3D,KAAM,WAAYuC,KAAM2F,EAAQnG,UACjE2C,IAHiC,CAAA,EAAA,YACnC0G,EAAAb,+CA2BF,kBApBMnC,EAAOiD,aAAejP,EAAaiP,EAAkBvQ,YAAcuQ,EACnE/P,EACJ+P,aAAejP,EACViP,EAAkB/P,QAEE,QAArB+M,EAACgD,aAAG,EAAHA,EAAa/P,eAAO,IAAA+M,EAAAA,EAAI9K,OAAO8N,GAChC1H,EAAa0H,aAAejP,EAAaiP,EAAkBlQ,OAAS,EACpEC,EAAOiQ,aAAejP,EAAaiP,EAAkBjQ,KAAO,EAC5DC,EAASgQ,aAAejP,EAAaiP,EAAkBhQ,OAAS,EAEhEiN,EAAaJ,EAAQhG,OAAO,GAC5BqG,EAAYD,EAAW/F,MACvBiG,EAAM9D,GACRd,WAAWQ,KAAoB,QAAhBqE,EAAAH,EAAWpN,aAAK,IAAAuN,OAAA,EAAAA,EAAEC,QAAS,QAAS,CACrD5N,KAAIsN,EACJ9M,QAAOA,EACPF,KAAIA,EACJC,OAAMA,EACNsI,WAAUA,IAEN,CAAA,EAAAhI,KAAKkO,eACT,CAAE/O,KAAM4J,EAAaf,WAAY3D,KAAM,WAAYuC,KAAMgG,GACzDC,mBAFF4C,EAAAb,OAIA/B,EAAI5E,WAAWQ,aAAIuE,EAAAL,EAAWpN,4BAAOwN,QAAS,QAAS,qBAEnD,OAAmB,QAAnBE,EAAAV,EAAQ/F,mBAAW,IAAAyG,OAAA,EAAAA,EAAEpK,QACjB,CAAA,EAAA7C,KAAKkO,eACT,CACE/O,KAAM4J,EAAaf,WACnB3D,KAAM,WACNuC,KAAM2F,EAAQ/F,aAEhBuC,IAPoC,CAAA,EAAA,YACtC0G,EAAAb,4CAWJ,MAAO,CAAA,WAGL,MAAc,WAAd3F,EAAK5E,KAAiB,CAAA,EAAA,KAClBoG,EAAaxB,EACnBF,EAAaa,cAAe,EAC5BuB,EAAApC,EAA4B0B,EAAW1F,YAC7B,CAAA,EAAA/E,KAAKiP,cAAcxE,EAAW1F,YAAagE,IADH,CAAA,EAAA,oBAC9CgD,EAAA0D,wBACA1D,EAAA,wBAEJ,OAJAZ,EAAarB,eAIN,CAAA,EAAAf,EAAae,sBAGtB,MAAkB,aAAdb,EAAK5E,MACP0E,EAAagB,gBAAiB,EACvB,CAAA,IAGS,UAAdd,EAAK5E,MACP0E,EAAaiB,aAAc,EACpB,CAAA,IAGS,QAAdf,EAAK5E,KAAc,CAAA,EAAA,KACfgI,EAAUpD,EAEK,CAAA,EAAAjJ,KAAKiP,cAAc5C,EAAQ3F,YAAaqC,aAAvDuD,EAASmD,EAAAb,OAGN7L,EAAI,qBAAG,OAAAA,EAAIuJ,EAAMzJ,QAClBsJ,GAAOG,EAAMvJ,GACnBgG,EAAad,WAAWQ,IAAI4D,EAAQ1F,YAAawF,IAC3C,CAAA,EAAAnM,KAAKkO,eACT,CAAE/O,KAAM4J,EAAaf,WAAY3D,KAAM,MAAOuC,KAAMyF,EAAQzF,MAC5DmC,KAL4B,CAAA,EAAA,YAU9B,GAPA0G,EAAAb,OAII7F,EAAagB,iBACfhB,EAAagB,gBAAiB,GAE5BhB,EAAaiB,YACf,MAAM,CAAA,EAAA,8BAXwBjH,mBAkBlC,OAHIgG,EAAaiB,cACfjB,EAAaiB,aAAc,GAEtB,CAAA,WAGL,GAAc,UAAdf,EAAK5E,KAAL,MAAqB,CAAA,EAAA,IACjB+H,EAAYnD,qBAEX,MAAM,CAAA,EAAAjJ,KAAKiP,cAAc7C,EAAUtF,UAAWiC,mBAA9C0G,EAA2Db,OAC1D,CAAA,EAAA5O,KAAKkO,eACT,CAAE/O,KAAM4J,EAAaf,WAAY3D,KAAM,QAASuC,KAAMwF,EAAUxF,MAChEmC,IAH8D,CAAA,EAAA,YAShE,OARA0G,EAAAb,OAKI7F,EAAagB,iBACfhB,EAAagB,gBAAiB,GAE5BhB,EAAaiB,YACT,CAAA,EAAA,mBAOV,OAJIjB,EAAaiB,cACfjB,EAAaiB,aAAc,GAGtB,CAAA,WAGT,GAAkB,UAAdf,EAAK5E,KACP,MAAQ,CAAA,EAAA4E,EAAmB3F,OAG7B,GAAkB,iBAAd2F,EAAK5E,KAAyB,CAIhC,GAHMqG,EAAQzB,EAA0B9J,UAG1B4E,KAFRT,EAAQyF,EAAad,WAAWU,IAAI+B,IAGxC,KAAqC,MAAjCA,EAAKC,OAAOD,EAAK7H,OAAS,GACtB,IAAIxC,MAAM,8BAEV,IAAIA,MAAM,oBAAaqK,EAAI,sBAGrC,MAAA,CAAA,EAAOpH,EACR,CAEG,MAAc,UAAd2F,EAAK5E,KAAgB,CAAA,EAAA,KACjBuG,EAAY3B,EACC,CAAA,EAAAjJ,KAAKiP,cAAcrE,EAAUhD,KAAMmB,aACxC,OADRnB,EAAO6H,EAAsDb,OAC/C,CAAA,EAAA5O,KAAKiP,cAAcrE,EAAU/C,MAAOkB,YACxD,OADMlB,EAAQ4H,EAAuDb,OAC9D,CAAA,EAAAxN,EAAewJ,EAAUlJ,IAAIkG,EAAmBC,YAGrD,GAAc,cAAdoB,EAAK5E,KAAL,MAAyB,CAAA,EAAA,IACrBwG,EAAgB5B,EAClBjG,EAAM,EACN8H,GAAmB,qBAEhB,OAAA9H,EAAM6H,EAActD,MAAM1E,QACzBkI,EAAKF,EAActD,MAAMvE,KAEf,CAAA,EAAAhD,KAAKiP,cAAclE,EAAG9B,KAAMF,KAHP,CAAA,EAAA,YAKrC,OAFA+B,EAAU2E,SAEI,QAAV1E,EAAGrJ,IAAiBoJ,EAGV,OAAVC,EAAGrJ,IAAeoJ,EACpB,CAAA,EAAOA,UAHP,CAAA,GAAO,GAOX,KAAA,GAAA,MAAA,CAAA,EAAOA,WAGT,GAAkB,iBAAd7B,EAAK5E,KAGP,OAFM2G,EAAe/B,EAEd,CAAA,EAAA,qBAAmBE,EAAA,GAAAC,EAAA,EAAlBA,EAAkBC,UAAAxG,OAAlBuG,IAAAD,EAAkBC,GAAAC,UAAAD,GACxB,OAAAI,EAAA,IAAIZ,IAAYU,gBAAgBC,MAAAC,EAAA8E,EAAA,CAAAtD,EAAcjC,GAAiBI,GAAI,GAAnE,GAGA,GAAc,aAAdF,EAAK5E,KAAL,MAAwB,CAAA,EAAA,IAM1B,GALM4G,EAAehC,EAKD,mBAJdoB,EAAOtB,EAAad,WAAWU,IAAIsC,EAAa9L,OAKpD,MAAMkB,MAAM,IAAIT,OAAAqL,EAAa9L,KAAI,wCAG7B+L,EAAM,GACiC9B,EAAA,EAA7B6C,EAAAhB,EAAa1F,YAAc,sBAA3B,OAAA6D,YAAL4C,GAACC,EAAA7C,GACVuG,GAAAzD,EAAAhB,GAAIjI,KAAW,CAAA,EAAAjD,KAAKiP,cAAcjD,GAAGjD,KADM,CAAA,EAAA,YAC3C4G,EAASpG,MAAA2C,EAAA,CAAAuD,EAAAb,mCADKxF,WAIT,KAAA,GAAA,MAAA,CAAA,EAAMpJ,KAAKwP,oBAAoBnF,EAAMa,EAAK,CAC/ClD,WAAYe,EAAaf,WACzBvI,KAAMwL,EAAa3G,IAAI,GACvB5E,OAAQuL,EAAa3G,IAAI,MAH3B,KAAA,GAAA,MAAA,CAAA,EAAOmL,kBAOL,MAAc,WAAdxG,EAAK5E,KAAiB,CAAA,EAAA,IAGO,kBAFzBiH,EAAarC,GAEJzE,OAAOH,KAAuB,CAAA,EAAA,KACrCkH,EAAOD,EAAW9G,OACxBoL,IAAAC,GAAA9G,EAAad,YAAWQ,IACtBqH,GAAA,CAAAvE,EAAKpM,MACC,CAAA,EAAAa,KAAKiP,cAAc3D,EAAW7G,OAAQsE,oBAF9C6G,GAEErG,MAAAsG,GAAAC,GAAAlQ,OAAA,CAAA6P,EAAAb,+BAEkC,kBAA3BtD,EAAW9G,OAAOH,KAAwB,CAAA,EAAA,KAC7CmH,GAAaF,EAAW9G,OAIxBiH,GAAmB,IAAIvE,EAC3BsE,GAAWrE,WAAWjE,MAAM,EAAGsI,GAAWrE,WAAWtE,OAAS,GAC9D2I,GAAWlH,KAEe,CAAA,EAAAtE,KAAKiP,cAAcxD,GAAkB1C,aAQ7D,OARE2C,GAAgB+D,EAAAb,OAKhBjD,GAAgBH,GAAWrE,WAAWqE,GAAWrE,WAAWtE,OAAS,GAEvE+I,GAAmB,GACI,iBAAvBD,GAActH,KAAuB,CAAA,EAAA,KACvCuH,GAAoBD,GAAmCxM,qBAC9C,MAAuB,yBAAvBwM,GAActH,KAA+B,CAAA,EAAA,IAC5B,CAAA,EAAArE,KAAKiP,cAC5BtD,GAA2ClE,YAC5CsB,mBAFF6C,GAAoB6D,EAGnBb,cAED,KAAA,GAAA,MAAMvO,MAAM,gEAGmB,OAAjC0P,GAAArE,GAAasE,GAAApE,GAA0B,CAAA,EAAA5L,KAAKiP,cAAc3D,EAAW7G,OAAQsE,YAA7EgH,GAA8BC,IAAGP,oBAGnC,KAAA,GAAA,MAAA,CAAA,EAAO,cAGL,MAAc,kBAAdxG,EAAK5E,KAAwB,CAAA,EAAA,IAClB,CAAA,EAAArE,KAAK6L,yBAAyB5C,EAA2BF,IAAtE,KAAA,GAAA,MAAA,CAAA,EAAO0G,kBAGL,GAAc,iBAAdxG,EAAK5E,KAAL,MAA4B,CAAA,EAAA,IAExByH,GAAM,CAAA,OAEImE,GAHShH,EAGQ5B,yBAAjB,OAAA6I,cAALlE,GAACiE,GAAAC,IACVC,GAAArE,GAAW,CAAA,EAAA9L,KAAKiP,cAAcjD,GAAE7M,KAAM4J,KADF,CAAA,EAAA,YAC8B,OAA9DqH,GAACX,EAA8Cb,OAAqB,CAAA,EAAA5O,KAAKiP,cAC3EjD,GAAE1I,MACFyF,YAFFoH,GAA+DC,IAAGX,mCADpDS,YAOhB,KAAA,GAAA,MAAA,CAAA,EAAOpE,YAGL,GAAc,gBAAd7C,EAAK5E,KAAL,MAA2B,CAAA,EAAA,IAEvBwF,GAAM,QAEOwG,GAHDpH,EAGW1B,yBAAV,OAAA+I,cAARnE,GAAIkE,GAAAC,IACbC,IAAAC,GAAA3G,IAAI5G,KAAW,CAAA,EAAAjD,KAAKiP,cAAc9C,GAAMpD,KADR,CAAA,EAAA,YAChCwH,GAAShH,MAAAiH,GAAA,CAAAf,EAAAb,mCADQ0B,YAInB,KAAA,GAAA,MAAA,CAAA,EAAOzG,4BAEV,EAEa4D,EAAAtN,UAAA0L,yBAAd,SACEwB,EACAtE,oHAGmB,KAAA,EAAA,MAAA,CAAA,EAAM/I,KAAKiP,cAAc5B,EAAOlG,WAAW,GAAI4B,WAA9DuE,EAAeN,EAAA4B,OAEV7L,EAAI,mBAAG,OAAAA,EAAIsK,EAAOlG,WAAWtE,QAC9B0K,EAAaF,EAAOlG,WAAWpE,GAEhCsK,EAAOlG,WAAWpE,EAAI,GAAiCyC,eAAiB8H,IAC3EA,EAAc,CAAA,GAGQ,iBAApBC,EAAWlJ,KAAuB,CAAA,EAAA,IACpCiJ,EAAcA,EAAaC,EAAgCpO,eARnB,CAAA,EAAA,WAS/B,MAAoB,yBAApBoO,EAAWlJ,KAA+B,CAAA,EAAA,IAC7C4E,EAAOsE,EAEC/D,EAAA8D,EACL,CAAA,EAAAtN,KAAKiP,cAAchG,EAAKxB,YAAasB,mBAD9CuE,EAAc9D,EACXwD,EAAwD4B,sBAElD,GAAoB,aAApBrB,EAAWlJ,KAAX,MAA8B,CAAA,EAAA,IAIvC,GACE,OAHIgG,EAAOiD,GADPrC,EAAesC,GACiBpO,QAInCkO,EAAOlG,WAAWpE,EAAI,GAAiCyC,aAGxD,OADA8H,EAAc,KACL,CAAA,EAAA,IAGX,GAAoB,mBAATjD,EACT,MAAMhK,MAAM,IAAIT,OAAAqL,EAAa9L,KAAI,wCAE7B+L,EAAM,GACiC9B,EAAA,EAA7BoD,EAAAvB,EAAa1F,YAAc,oBAA3B,OAAA6D,YAAL4C,EAACQ,EAAApD,GACV0D,GAAAJ,EAAAxB,GAAIjI,KAAW,CAAA,EAAAjD,KAAKiP,cAAcjD,EAAGjD,KADM,CAAA,EAAA,UAC3C+D,EAASvD,MAAAmD,EAAA,CAAAM,EAAA4B,iCADKxF,UAIF,KAAA,EAAA,MAAA,CAAA,EAAMpJ,KAAKwP,oBAAoBnF,EAAKmD,KAAKF,GAAcpC,EAAK,CACxElD,WAAYe,EAAaf,WACzBvI,KAAMwL,EAAa3G,IAAI,GACvB5E,OAAQuL,EAAa3G,IAAI,qBAH3BgJ,EAAcN,gBAMd,KAAA,GAAA,MAAM3M,MAAM,mDAzC8B0C,kBA6C9C,MAAO,CAAA,OAAgBgB,IAAhBuJ,EAA4B,KAAOA,SAC3C,EACFG,CAAD,ICxmBagD,GAAgB,CAC3BC,SAAQ,WACN,MAAO,gEACR,EACDC,SAAU,SAACC,GACT,YADS,IAAAA,IAAAA,EAAqC,MPN5C,SAA8BtN,GAClC,IAAKA,EACH,OAAO,KAET,GAAqB,iBAAVA,EACT,OAAO,IAAIuN,KAAKvN,GAElB,GAAIA,aAAiBuN,OAASC,MAAMxN,EAAMyN,WACxC,OAAOzN,EAGT,GAAqB,iBAAVA,EACT,OAAO,KAGT,IAAM0N,EAAWpP,OAAO0B,GACxB,IAAK0N,EAASnO,OACZ,OAAO,KAGT,IAAMoO,EAAa,SAACC,GAClB,IAAKA,IAAOA,EAAGrO,OACb,OAAOsO,IAGT,IAAMC,EAAIC,SAASH,EAAI,IACvB,OAAKJ,MAAMM,GAKPF,EAAG9R,WAAW,OACT,EAEL8R,EAAG9R,WAAW,OACT,EAEL8R,EAAG9R,WAAW,OACT,EAEL8R,EAAG9R,WAAW,OACT,EAEL8R,EAAG9R,WAAW,OACT,EAEL8R,EAAG9R,WAAW,OACT,EAEL8R,EAAG9R,WAAW,OACT,EAEL8R,EAAG9R,WAAW,OACT,EAEL8R,EAAG9R,WAAW,OACT,EAEL8R,EAAG9R,WAAW,OACT,EAEL8R,EAAG9R,WAAW,OACT,GAEL8R,EAAG9R,WAAW,OACT,GAGF+R,IAzCEC,EAAI,CA0Cf,EAEME,EAAc,SAACC,GACnB,OAAIA,EAAK,IACAA,EAAK,GAAKA,EAAK,IAAOA,EAAK,KAE3BA,CAEX,EAEMC,EAAkB,SACtBC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,GAAIJ,EAAQ,IAAMC,EAAM,IAAMC,GAAS,IAAMC,GAAQ,IAAMC,GAAM,GAC/D,OAAO,KAGT,IAAMC,EAAK,IAAIlB,KAAKY,EAAMC,EAAOC,EAAKC,EAAOC,EAAMC,EAAI,GACvD,OAAQhB,MAAMiB,EAAGhB,WAAkB,KAALgB,CAChC,EAEMC,EAAYhB,EACfiB,QAAQ,IAAK,KACbC,cACAC,MAAM,UACHC,EAAKJ,EAAU5G,IAAIiH,YAGrBC,EAAId,EAAgBY,EAAG,GAAIA,EAAG,GAAK,EAAGA,EAAG,GAAIA,EAAG,IAAM,EAAGA,EAAG,IAAM,EAAGA,EAAG,IAAM,GAClF,OAAIE,KAKJA,EAAId,EACFF,EAAYc,EAAG,IACfnB,EAAWe,EAAU,IACrBI,EAAG,GACHA,EAAG,IAAM,EACTA,EAAG,IAAM,EACTA,EAAG,IAAM,IAGFE,GAITA,EAAId,EACFF,EAAYc,EAAG,IACfnB,EAAWe,EAAU,IACrBV,EAAYc,EAAG,IACfA,EAAG,IAAM,EACTA,EAAG,IAAM,EACTA,EAAG,IAAM,KAMJ,KACT,CO/HIG,CAAoB3B,IAAkB,IAAIC,IAAM,EAClD2B,MA8BF,SAAe1P,EAAe2P,EAAYC,QAAZ,IAAAD,IAAAA,EAAUtB,UAAE,IAAAuB,IAAAA,EAAQ,GAChD,IAAMC,EAAgB,GAChBC,EAAY9B,MAAM2B,GACxBA,EAAOG,EAAY9P,EAAQ2P,EAE3B,IAAI1P,EADJD,EAAQ8P,EAAY,EAAI9P,EAExB,KAAOC,EAAI0P,GACTE,EAAI1P,KAAKF,GACTA,GAAK2P,EAEP,OAAOC,CACT,EAxCEE,MAAO,eAAC,IAAkB1J,EAAA,GAAAC,EAAA,EAAlBA,EAAkBC,UAAAxG,OAAlBuG,IAAAD,EAAkBC,GAAAC,UAAAD,GAExB,OADA0J,QAAQC,IAAGxJ,MAAXuJ,QAAe3J,GACRA,EAAKtG,OAAS,EAAIsG,EAAK,GAAK,IACpC,EACD6J,OAAQ,SAACC,EAAYC,GACnB,YADmB,IAAAA,IAAAA,EAAwB,MAC9B,OAAbA,EAA0B,OAAND,EAAaA,GAAKC,CAAQ,EAChDC,OAAQ,SAACb,GAAwB,OAAAA,aAAazB,IAAI,EAClDuC,WAAY,SAACH,GAAwB,MAAa,mBAANA,CAAgB,EAC5DI,SAAU,SAACJ,GAAwB,MAAa,iBAANA,CAAc,EACxDK,eAAgB,SAACxH,EAA8ByH,GAA8B,cAAOzH,EAAIyH,EAAS,EACjGvR,KAAMA,KACN/B,OAAQA,OACR4B,MAAOA,MACP4M,KAAMA,KAEN+E,sBAAuB,WAAc,EAErCC,oBAAqB,WAA+B,MAAC,CAAE,CAAC,GC2B1D,IAAAC,GAAA,WAAA,SAAAA,IACW1T,KAAM0C,OAAY,EAiB5B,CAAD,OAfEgR,EAAAvT,UAAAwT,UAAA,WACE,OAAOpR,EAAavC,KAAK0C,OAAO,KAGlCgR,EAAAvT,UAAAyT,YAAA,WACE,OAAOpR,EAAexC,KAAK0C,OAAO,KAGpCgR,EAAAvT,UAAA0T,QAAA,WACE,OAAkB7T,KAAK0C,OAAO1C,KAAK0C,OAAOG,OAAS,GNLxC,GAAG,IMQhB6Q,EAAAvT,UAAA2T,UAAA,WACE,OAAoB9T,KAAK0C,OAAO1C,KAAK0C,OAAOG,OAAS,GNL1C,GAAG,IMOjB6Q,CAAD,CAlBA,GAoBAK,GAAA,WAAA,SAAAA,IACU/T,KAAagU,cAAiB,KAC9BhU,KAAWiU,YAAG,EA2pBvB,CAAD,OAppBEF,EAAA5T,UAAAuO,MAAA,SAAMhM,EAAiBvD,EAAoBkF,cAApB,IAAAlF,IAAAA,EAAkB,kBAAE,IAAAkF,IAAAA,EAAe,UACxDrE,KAAKiU,YAAc9U,EACnB,IAAM2J,EAAM,CAAE3J,KAAIA,EAAEkF,KAAIA,EAAEoF,MAAO,GAAI7C,KAAM,IAE3C,IAAKlE,IAAWA,EAAOG,OACrB,OAAOiG,EAGT,IAEE,IAAMoL,EAAelU,KAAKmU,yBAAyBzR,EAAQ,GAG3D1C,KAAKoU,oBAAoBF,EAAcpL,EAUxC,CATC,MAAOvJ,GACP,IAAM0K,EAAM1K,EACN4C,EAA0B,QAAlBqH,EAAAxJ,KAAKgU,qBAAa,IAAAxK,EAAAA,EAAK,GACrC,MAAM,IAAIjJ,EACRuI,EAAI3J,KACJoD,EAAaJ,GACbK,EAAeL,GACf8H,EAAItK,SAAWiC,OAAOqI,GAEzB,CACD,OAAOnB,GAGDiL,EAAA5T,UAAAiU,oBAAR,SAA4BF,EAAiCpL,GAiB3D,IAjBF,IAqTC/I,EAAAC,KApTOqU,EAAU,SAAC3R,EAAiB4R,GAChC,IAAMC,EAAmBxU,EAAKoU,yBAC5BzR,EACAH,EAAaG,EAAO4R,KAEhBE,EAAU,CAAErV,KAAM2J,EAAI3J,KAAMyH,KAAM,GAAiB6C,MAAO,IAEhE,OADA1J,EAAKqU,oBAAoBG,EAAkBC,GACpCA,EAAQ5N,IACjB,EAEM6N,EAAc,SAACC,EAAeC,EAA2B/R,GAG7D,OAFAA,EAAOgS,OAAO,EAAGhS,EAAOC,QACxBgB,EAAc6Q,EAAMC,GAAWE,SAAQ,SAAAvT,GAAK,OAAAsB,EAAOK,KAAK3B,EAAE,MACjDsB,EAAOC,MAClB,EAESE,EAAI,EAAGA,EAAImR,EAAarR,OAAQE,IAAK,CAK5C,IAJA,IAAM+R,EAAcZ,EAAanR,GAG7BgS,EAAK,EACFA,EAAKD,EAAYpS,OAAOG,QACzBX,EAAa4S,EAAYpS,OAAOqS,MAASrU,EAAWsU,QACtDF,EAAYpS,OAAOkS,OAAOG,EAAI,GAE9BA,IAGJ,GAAKD,EAAYpS,OAAOG,OAAxB,CAIA,IAAMoS,EAAaH,EAAYpS,OAAO,GAChCwS,EAAcJ,EAAYpS,OAAOG,OAAS,EAAIiS,EAAYpS,OAAO,GAAK,KAC5E1C,KAAKgU,cAAgBiB,EAErB,IAAME,EAA2B,GAGjC,GAAIjT,EAAa+S,KAAgBvU,EAAWsU,QAC1ClM,EAAIlC,KAAK3D,KACP,IAAI2B,EAAYxC,EAAc6S,GAAuB5S,EAAY4S,UAE9D,GACyB,QAA9B7S,EAAc6S,IACiB,UAA9B7S,EAAc6S,IAA0D,QAA/B7S,EAAc8S,GACxD,CACA,IAAMtP,EAAwC,UAA9BxD,EAAc6S,GACxBG,EAAWhT,EAAc0S,EAAYpS,OAAOkD,EAAU,EAAI,IAM1DD,EAASxC,EALM2R,EAAYpS,OAAOQ,MACtC4R,EAAYpS,OAAO2S,WAAU,SAAAX,GAAQ,MAAwB,MAAxBtS,EAAcsS,EAAa,IAAI,EACpEI,EAAYpS,OAAO2S,WAAU,SAAAX,GAAQ,MAAwB,MAAxBtS,EAAcsS,EAAd,KAGE,KAAKtJ,KAAI,SAAAkK,GAAK,OAAAlT,EAAckT,EAAE,GAAa,IAIpF,IAAqB,KAFfC,GAAchS,EAAoBuR,EAAYpS,QAAQ,SAAAuQ,GAAK,MAAM,MAANA,CAAA,KAG/D,KAAM,uBAGR,IAAMsB,EAAmBvU,KAAKmU,yBAC5BW,EAAYpS,OACZH,EAAauS,EAAYpS,OAAO6S,GAAc,KAE1C7P,EAAU,CACdvG,KAAMiW,EACNxO,KAAM,GACN6C,MAAO,IAETzJ,KAAKoU,oBAAoBG,EAAkB7O,GAE3CoD,EAAIW,MAAMxG,KACR,IAAIwC,EAAgBC,EAASC,EAAQC,EAASvD,EAAYyS,EAAYpS,OAAO,KAEhF,MAAM,GAAkC,OAA9BN,EAAc6S,GAAsB,CAG7C,IAAqB,KAFfM,GAAchS,EAAoBuR,EAAYpS,QAAQ,SAAAuQ,GAAK,MAAM,MAANA,CAAA,KAG/D,KAAM,sBAYR,IATA,IAAM/M,EAASmO,EAAQS,EAAYpS,OAAQ6S,GAAc,GAGnDxP,EAAgB0O,EAFhBe,GAAkBV,EAAYpS,OAAOQ,MAAM,EAAGqS,IAEDjV,EAAeS,QAASoU,GACvEnV,KAAKyV,uBAAuBN,EAAgBK,IAC5CxV,KAAK0V,qBAAqBF,IAGxBG,EAAwB,GAE5BzB,EAAarR,OAASE,EAAI,GACuB,SAAjDX,EAAc8R,EAAanR,EAAI,GAAGL,OAAO,KACzC,CAEA,IAAMkT,EAAkB1B,IAAenR,GAEjC8S,EAAYtS,EAAoBqS,EAAgBlT,QAAQ,SAAAuQ,GAAK,MAAM,MAANA,CAAA,IAE7D6C,EAAkBF,EAAgBlT,OAAOQ,MAAM,EAAGqS,IAElDQ,EAAoBtB,EAAYqB,EAAiBxV,EAAeS,QAASoU,GAC3EnV,KAAKyV,uBAAuBN,EAAgBW,GAC5C9V,KAAK0V,qBAAqBI,GAExB9P,EAAWqO,EAAQuB,EAAgBlT,OAAQmT,EAAU,GAC3DF,EAAU1S,KACR,IAAI6C,EAASiQ,EAAmB/P,EAAU3D,EAAYuT,EAAgBlT,OAAO,KAGhF,CAGD,IAAI0D,OAAkCrC,EAEpCmQ,EAAarR,OAASE,EAAI,GACuB,SAAjDX,EAAc8R,EAAanR,EAAI,GAAGL,OAAO,KACQ,MAAjDN,EAAc8R,EAAanR,EAAI,GAAGL,OAAO,MAEzC0D,EAAWiO,EAAQH,EAAanR,EAAI,GAAGL,OAAQ,GAC/CK,KAGF+F,EAAIlC,KAAK3D,KACP,IAAIgD,EAAOF,EAAeG,EAAQyP,EAAWvP,EAAU/D,EAAY4S,IAEtE,MAAM,GAAkC,QAA9B7S,EAAc6S,GAAuB,CAC9C,GAA6C,MAAzC7S,EAAc0S,EAAYpS,OAAO,IACnC,KAAM,4CASR,IANA,IAAM4D,EAAU+N,EAAQS,EAAYpS,OAAQ,GACtCsT,EAAwB,GAG1BxP,GADAJ,OAAkCrC,OACGA,GAGvCmQ,EAAarR,OAASE,EAAI,IACwB,SAAjDX,EAAc8R,EAAanR,EAAI,GAAGL,OAAO,KACS,WAAjDN,EAAc8R,EAAanR,EAAI,GAAGL,OAAO,KACQ,YAAjDN,EAAc8R,EAAanR,EAAI,GAAGL,OAAO,MAC3C,CACA,GAAqD,SAAjDN,EAAc8R,EAAanR,EAAI,GAAGL,OAAO,IAAgB,CAC3D,GAAI0D,EACF,MAAM,IAAI/F,MAAM,yCAGlB+F,EAAWiO,EAAQH,EAAanR,EAAI,GAAGL,OAAQ,EAChD,CAED,GAAqD,YAAjDN,EAAc8R,EAAanR,EAAI,GAAGL,OAAO,IAAmB,CAC9D,GAAI8D,EACF,MAAM,IAAInG,MAAM,yCAGlBmG,EAAc6N,EAAQH,EAAanR,EAAI,GAAGL,OAAQ,EACnD,CAED,GAAqD,WAAjDN,EAAc8R,EAAanR,EAAI,GAAGL,OAAO,IAAkB,CAC7D,IAAMuT,EAAW1S,EAAoB2Q,EAAanR,EAAI,GAAGL,QAAQ,SAAAuQ,GAAK,MAAM,MAANA,CAAS,IACzEiD,EAAS,CAAA,EAEf,GAAiB,IAAbD,EACFC,EAAO3W,MAAQ,CAAEJ,KAAMiD,EAAc8R,EAAanR,EAAI,GAAGL,OAAO,UAC3D,GAAiB,IAAbuT,EACTC,EAAO3W,MAAQ,CACbJ,KAAMiD,EAAc8R,EAAanR,EAAI,GAAGL,OAAO,IAC/CqK,MAAO3K,EAAc8R,EAAanR,EAAI,GAAGL,OAAO,UAE7C,GAAiB,IAAbuT,EACTC,EAAO3W,MAAQ,CACbJ,KAAMiD,EAAc8R,EAAanR,EAAI,GAAGL,OAAO,IAC/CqK,MAAO3K,EAAc8R,EAAanR,EAAI,GAAGL,OAAO,UAE7C,GAAiB,IAAbuT,EACT,MAAM,IAAI5V,MACR,gGAIJ6V,EAAOtP,KAAOyN,EAAQH,EAAanR,EAAI,GAAGL,OAAQuT,EAAW,GAE7DD,EAAQ/S,KAAKiT,EACd,CAEDnT,GACD,CAED,IAAKiT,EAAQnT,OACX,MAAM,IAAIxC,MAAM,sBAGlByI,EAAIlC,KAAK3D,KACP,IAAIoD,EAAcC,EAAS0P,EAAS5P,EAAUI,EAAanE,EAAY4S,IAE1E,MAAM,GAAkC,aAA9B7S,EAAc6S,GACvBnM,EAAIlC,KAAK3D,KAAK,IAAIkC,QACb,GAAkC,UAA9B/C,EAAc6S,GACvBnM,EAAIlC,KAAK3D,KAAK,IAAImC,QACb,GAAkC,WAA9BhD,EAAc6S,GACvBnM,EAAIlC,KAAK3D,KACP,IAAI6B,EACFgQ,EAAYpS,OAAOG,OAAS,EACxB7C,KAAK0V,qBAAqBZ,EAAYpS,OAAOQ,MAAM,SACnDa,EACJ1B,EAAY4S,UAGX,GAAkC,UAA9B7S,EAAc6S,GAAyB,CAChD,GAAkC,IAA9BH,EAAYpS,OAAOG,OACrB,MAAM,IAAIxC,MAAM,mEAElB,IAAM4E,EAAY7C,EAAc0S,EAAYpS,OAAO,IAS7CyT,EAASnW,KAAK0V,qBAAqBZ,EAAYpS,OAAOQ,MAAM,IAElE4F,EAAIlC,KAAK3D,KAAK,IAAI+B,EAAUC,EAAWkR,EAAQ9T,EAAY4S,IAC5D,MAAM,GAAkC,QAA9B7S,EAAc6S,GAAuB,CAG9C,IAAqB,KAFfM,GAAchS,EAAoBuR,EAAYpS,QAAQ,SAAAuQ,GAAK,MAAM,MAANA,CAAA,KAG/D,KAAM,sBAGR,IAAMtM,GAAcvE,EAAc0S,EAAYpS,OAAO,IAC/CgE,GAAc1G,KAAK0V,qBAAqBZ,EAAYpS,OAAOQ,MAAM,EAAGqS,KACpEa,GAAU/B,EAAQS,EAAYpS,OAAQ6S,GAAc,GAE1DzM,EAAIlC,KAAK3D,KAAK,IAAIwD,EAAQC,GAAaC,GAAayP,GAAS/T,EAAY4S,IAC1E,MAAM,GAAkC,UAA9B7S,EAAc6S,GAAyB,CAChD,IAAMM,GAEN,IAAqB,KAFfA,GAAchS,EAAoBuR,EAAYpS,QAAQ,SAAAuQ,GAAK,MAAM,MAANA,CAAA,KAG/D,KAAM,2BAIFlN,EAAgB0O,EADhBe,GAAkBV,EAAYpS,OAAOQ,MAAM,EAAGqS,IACDjV,EAAeS,QAASoU,GACvEnV,KAAKyV,uBAAuBN,EAAgBK,IAC5CxV,KAAK0V,qBAAqBF,IAH9B,IAAMA,GAKA5O,GAAOyN,EAAQS,EAAYpS,OAAQ6S,GAAc,GAEvDzM,EAAIlC,KAAK3D,KAAK,IAAI4D,EAAUd,EAAea,GAAMvE,EAAY4S,IAC9D,MAAM,GAAkC,WAA9B7S,EAAc6S,GAA0B,CACjD,IAAIoB,GAAU9S,EAAoBuR,EAAYpS,QAAQ,SAAAuQ,GAAK,MAAM,OAANA,CAAA,IACvDoD,GAAU,IACZA,GAAUvB,EAAYpS,OAAOG,QAG/B,IAAMyT,GAAS,CACbnX,KAAM2V,EAAYpS,OACfQ,MAAM,EAAGmT,IACTjL,KAAI,SAAAkK,GAAK,OAAAlT,EAAckT,MACvBiB,KAAK,IACRxJ,MACE+H,EAAYpS,OACTQ,MAAMmT,GAAU,GAChBjL,KAAI,SAAAkK,GAAK,OAAAlT,EAAckT,MACvBiB,KAAK,UAAOxS,GAGb6C,GAAO,CAAA,EACbkC,EAAIlC,KAAK3D,KAAK,IAAI8D,EAAWuP,GAAQ1P,QAAM7C,EAAW1B,EAAY4S,IACnE,MAAM,GAAkC,SAA9B7S,EAAc6S,GAAwB,CAC/C,IAAMuB,GAAcjT,EAAoBuR,EAAYpS,QAAQ,SAAAuQ,GAAK,MAAM,WAANA,CAAA,IACjE,GAAIuD,GAAc,EAChB,MAAMnW,MAAM,+BAGd,IAAMoW,GAAS,CACbtX,KAAM2V,EAAYpS,OACfQ,MAAM,EAAGsT,IACTpL,KAAI,SAAAkK,GAAK,OAAAlT,EAAckT,MACvBiB,KAAK,KAGJvP,GAAQ7D,EAAY2R,EAAYpS,OAAOQ,MAAMsT,GAAc,GAAI,KAAKpL,KAAI,SAAAkK,GAC5E,MAAO,CACLnW,KAAMiD,EAAckT,EAAE,IACtBvI,MAAoB,IAAbuI,EAAEzS,OAAeT,EAAckT,EAAE,SAAMvR,EAElD,IAEM6C,GAAO,CAAA,EAEbkC,EAAIlC,KAAK3D,KAAK,IAAI8D,EAAW0P,GAAQ7P,GAAMI,GAAO3E,EAAY4S,IAC/D,MAAM,GAAIR,EAAYK,EAAYpS,OAAQpC,EAAea,WApQrB,IAoQsD,CACzF,IAAMuV,GAAevT,EAAY2R,EAAYpS,OAAQ,KAC/C8B,GAASxE,KAAK0V,qBAAqBgB,GAAa,IAChDjS,GAASzE,KAAK0V,qBAAqBgB,GAAa,IACtD5N,EAAIlC,KAAK3D,KAAK,IAAIsB,EAAWC,GAAQC,GAAQpC,EAAYqU,GAAa,GAAG,KAC1E,MAAUjC,EAAYK,EAAYpS,OAAQpC,EAAeS,QAASoU,GACjErM,EAAIlC,KAAK3D,KAAKjD,KAAKyV,uBAAuBN,EAAgBL,EAAYpS,SAEtEoG,EAAIlC,KAAK3D,KAAKjD,KAAK0V,qBAAqBZ,EAAYpS,QAnRrD,CAqRF,GAGKqR,EAAA5T,UAAAwW,kBAAR,SAA0BC,EAAYC,EAAeC,GAOnD,MALgC,MAA5B1U,EAAcwU,EAAEC,KAAmB3U,EAAa0U,EAAEC,MAAYnW,EAAW+C,gBAC3EoT,IACAC,KAGKF,EAAE1T,MAAM2T,EAAOC,IAGhB/C,EAAA5T,UAAA4W,0BAAR,SAAkCC,EAAmBtU,GAInD,IAHA,IAEIuU,EAA2B,KACtBlU,EAAI,EAAGA,EAAIiU,EAAQnU,OAAQE,IAAK,CACvC,IAAMmU,EAAU9U,EAAcM,EAAOsU,EAAQjU,KAC7CkU,EAAWA,GAEPjX,KAAK0V,qBAAqB1V,KAAK2W,kBAAkBjU,EAPzC,EAOwDsU,EAAQjU,KAE5E,IAAMoU,EAASpU,EAAI,EAAIiU,EAAQnU,OAASmU,EAAQjU,EAAI,GAAKL,EAAOG,OAC1DuU,EAAYpX,KAAK0V,qBACrB1V,KAAK2W,kBAAkBjU,EAAQsU,EAAQjU,GAAK,EAAGoU,IAGjDF,EAAW,IAAItP,EAAUsP,EAAUC,EAASE,EAAW/U,EAAYK,EAAO,IAC3E,CAED,OAAOuU,GAGDlD,EAAA5T,UAAAsV,uBAAR,SAA+B4B,EAAmB3U,GAGhD,IAFA,IAAII,EAAQ,EACNwU,EAAgC,GAC7BvU,EAAI,EAAGA,EAAIsU,EAAQxU,OAAQE,IAAK,CACvC,IAAMmU,EAAUxU,EAAO2U,EAAQtU,IACzBwU,EAAevX,KAAK2W,kBAAkBjU,EAAQI,EAAOuU,EAAQtU,IACnEuU,EAAWrU,KAAK,CACdgG,KAAMjJ,KAAK0V,qBAAqB6B,GAChC7V,GAAIU,EAAc8U,KAGpBpU,EAAQuU,EAAQtU,GAAK,CACtB,CAOD,OALAuU,EAAWrU,KAAK,CACdgG,KAAMjJ,KAAK0V,qBAAqB1V,KAAK2W,kBAAkBjU,EAAQI,EAAOJ,EAAOG,WAGnE,IAAI6E,EAAc4P,EAAYjV,EAAYK,EAAO,MAIvDqR,EAAA5T,UAAAgU,yBAAR,SAAiCzR,EAAiBiR,GAMhD,IALA,IAAM6D,EAA2B,GAE7B9X,EAAS,EAETD,EAAO,IAAIiU,GACN3Q,EAAI,EAAGA,EAAIL,EAAOG,OAAQE,IAAK,CACtC,IAAMZ,EAAQO,EAAOK,GACf0U,EAAQlV,EAAaJ,GACrBuV,EAAUlV,EAAeL,GACzBmB,EAAQlB,EAAcD,GAG5B,GAFAnC,KAAKgU,cAAgB7R,EAEjBsV,GAAS9D,IAKPjU,IAAWgY,GAAY,MAAM/V,SAAS2B,KAExCkU,EAAMvU,KAAKxD,GACXA,EAAO,IAAIiU,IAGbjU,EAAKiD,OAAOO,KAAKd,GAGF,IAAXzC,IACFA,EAASgY,GAKPA,EAAUhY,GACZ,KAGL,CAMD,OAJID,EAAKiD,OAAOG,QACd2U,EAAMvU,KAAKxD,GAGN+X,GAGDzD,EAAoB5T,UAAAuV,qBAA5B,SAA6BhT,GAA7B,IA8NC3C,EAAAC,KA7NC,GAAsB,IAAlB0C,EAAOG,OACT,MAAM,IAAIxC,MAAM,8BAElB,IAAMsX,EAAYjV,EAAOA,EAAOG,OAAS,GACzC,GAAiC,MAA7BT,EAAcuV,IAAsBzV,EAAayV,KAAejX,EAAW+C,cAC7E,MAAM,IAAIpD,MAAM,oCAMlB,GAHAL,KAAKgU,cAAgBtR,EAAO,GAGN,IAAlBA,EAAOG,QAAmC,IAAlBH,EAAOG,QAA6C,MAA7BT,EAAcM,EAAO,IAAc,CACpF,IAAMuS,EAAavS,EAAO,GACpBkV,EAAY1V,EAAa+S,GAE/B,GNzfA,SAA6B2C,GACjC,OACEA,IAAclX,EAAW+C,eACzBmU,IAAclX,EAAWmX,eACzBD,IAAclX,EAAWoX,aACzBF,IAAclX,EAAWqX,WAE7B,CMkfUC,CAAmBJ,GACrB,OAAO,IAAIjT,EAAUsQ,GAChB,GAAI2C,IAAclX,EAAWuX,WAClC,OAAO,IAAIhR,EACTgO,EACmB,IAAlBvS,EAAOG,QAA6C,MAA7BT,EAAcM,EAAO,UAAgBqB,GAIjE,MAAM1D,MAAM,4BAAAT,OAA4B6O,KAAKyJ,UAAUjD,GAAc,KACtE,CAGD,IAAMkD,EAAiBhV,EAAYT,EAAQ,MAC3C,GAAIyV,EAAetV,OAAS,EAAG,CAC7B,IAIM8C,EAASxC,EAH2B,MAAxCf,EAAc+V,EAAe,GAAG,IAC5BA,EAAe,GAAGvD,OAAO,EAAGuD,EAAe,GAAGtV,OAAS,GACvDsV,EAAe,GACc,KAAK/M,KAAI,SAAAkK,GAAK,OAAAlT,EAAckT,EAAE,GAAa,IAExEf,EAAmBvU,KAAKmU,yBAAyBgE,EAAe,GAAI,GACpEzS,EAAU,CACdvG,KAAMa,KAAKiU,YACXrN,KAAM,GACN6C,MAAO,IAIT,OAFAzJ,KAAKoU,oBAAoBG,EAAkB7O,GAEpC,IAAIG,EAAiBH,EAASC,EAAQtD,EAAYK,EAAO,IACjE,CAGD,IAAM0V,EAAqBvU,EAAcnB,EAAQpC,EAAeO,YAChE,GAAIuX,EAAmBvV,OACrB,OAAO7C,KAAK+W,0BAA0BqB,EAAoB1V,GAI5D,IAAM2V,EAAMxU,EAAcnB,GAC1B,GAAI2V,EAAIxV,OAAQ,CAEd,IADA,IAAIyV,EAA2B,KACtBvV,EAAI,EAAGA,EAAIsV,EAAIxV,OAAQE,IAAK,CACnC,IAAMwV,EAAUF,EAAItV,GACdrB,EAAKU,EAAcM,EAAO6V,IAE5BC,EAAczV,EAAI,EAAIsV,EAAIxV,OAASwV,EAAItV,EAAI,GAAK,KAChD0V,EAAyB,OAAhBD,EAAuBpW,EAAcM,EAAO8V,IAAgB,KACzE,GAAoB,OAAhBA,GAAoC,MAAXC,GAA6B,MAAXA,EAiCxC,CACCC,EAAYJ,EAAW,GAAKtY,KAAK2W,kBAAkBjU,EAAQ,EAAG6V,GAApE,IACMI,EAAa3Y,KAAK2W,kBACtBjU,EACA6V,EAAU,EACVC,GAAe9V,EAAOG,QAElB+E,EAAgB0Q,GAAYtY,KAAK0V,qBAAqBgD,GACtD7Q,EAAQ7H,KAAK0V,qBAAqBiD,GACxCL,EAAW,IAAI3Q,EAAUC,EAAMlG,EAA2BmG,EAAOxF,EAAYK,EAAO,IACrF,KA3C+D,CAC9D,IAAI0U,EAA4B,KAEhC,EAAG,CACD,IAAMwB,EAAe7V,EAAI,EAAIsV,EAAIxV,OAASwV,EAAItV,EAAI,GAAK,KAEjD8V,EAAa7Y,KAAK2W,kBAAkBjU,EAAQ6V,EAAU,EAAGC,GACzDM,EAAc9Y,KAAK2W,kBACvBjU,EACA8V,EAAc,EACdI,GAAgBlW,EAAOG,QAGnBkW,EAAQ/Y,KAAK0V,qBAAqBmD,GAClCG,EAAShZ,KAAK0V,qBAAqBoD,GACzC1B,EAAY,IAAIzP,EAAUoR,EAAON,EAAQO,EAAQ3W,EAAYK,EAAO6V,EAAU,KAI9EE,EAAyB,QADzBD,IADAzV,EACkB,EAAIsV,EAAIxV,OAASwV,EAAItV,EAAI,GAAK,MAChBX,EAAcM,EAAO8V,IAAgB,IACtE,OAAwB,OAAhBA,IAAoC,MAAXC,GAA6B,MAAXA,IAGpD,GAAiB,OAAbH,EAAmB,CACrB,IAAMI,EAAY1Y,KAAK2W,kBAAkBjU,EAAQ,EAAG6V,GACpDD,EAAWtY,KAAK0V,qBAAqBgD,EACtC,CACDJ,EAAW,IAAI3Q,EACb2Q,EACA5W,EACA0V,EACA/U,EAAYK,EAAO,IAEtB,CAWF,CAED,GAAiB,OAAb4V,EACF,MAAMjY,MAAM,yBAGd,OAAOiY,CACR,CAID,IAAMW,ENngBJ,SAAwCvW,GAG5C,IAFA,IAAMiB,EAAsB,GAEnBZ,EAAI,EAAGA,EAAIL,EAAOG,OAAQE,IAAK,CACtC,IAAMa,EAASxB,EAAcM,EAAOK,IACtBb,EAAaQ,EAAOK,MAEpBrC,EAAW+C,gBAIV,MAAXG,EACFD,EAAUV,KAAKF,GACK,MAAXa,EACTb,EAAIW,EAAkBhB,EAAQK,EAAG,IAAK,KAClB,MAAXa,GAAwB,IAANb,EAC3BA,EAAIW,EAAkBhB,EAAQK,EAAG,IAAK,KAClB,MAAXa,GAAwB,IAANb,GAC3BY,EAAUV,KAAKF,GACfA,EAAIW,EAAkBhB,EAAQK,EAAG,IAAK,MAClB,MAAXa,IACTb,EAAIW,EAAkBhB,EAAQK,EAAG,IAAK,MAEzC,CAED,OAAOY,CACT,CMyeiBuV,CAA8BxW,GAE3C,GAAIuW,EAAKpW,OAAS,EAAG,CACnB,IAAMsW,EAAgB1W,EAAqBC,EAAQuW,GAC7C9R,EAAwB,GAE9B,IAASpE,EAAI,EAAGA,EAAIoW,EAActW,OAAQE,IAAK,CAC7C,IAAMqW,EAAmBD,EAAcpW,GAEvC,GAAU,IAANA,GAAkD,MAAvCX,EAAcgX,EAAiB,IAkB9CjS,EAAWlE,KAAKjD,KAAK0V,qBAAqB0D,QAlB1C,CACE,IAAM5T,EAAgF,MAAjEpD,EAAcgX,EAAiBA,EAAiBvW,OAAS,IAC1E2C,GACF4T,EAAiBC,MAEnB,IAAMC,EAAoBF,EAAiBlW,MAAM,EAAGkW,EAAiBvW,OAAS,GACxE0W,EAAcvZ,KAAK0V,qBAAqB4D,GAE9CnS,EAAWlE,KACT,IAAIuE,EACF+R,EACA/T,EACAnD,EAAY+W,EAAiB,KAIlC,CAGF,CAED,OAAO,IAAIlS,EAAkBC,EAAY9E,EAAYK,EAAO,IAC7D,CAGD,GAAIA,EAAOG,OAAS,GAAkC,MAA7BT,EAAcM,EAAO,IAAa,CACzD,IAAM8W,EAA8D,MAA7CpX,EAAcM,EAAOA,EAAOG,OAAS,IACxD2W,GAEF9W,EAAO2W,MAET,IAAM5M,EAAOrK,EAAcM,EAAO,IAI5BuG,IADAsQ,EADepW,EADfmW,EAAoB5W,EAAOQ,MAAM,EAAGR,EAAOG,OAAS,GACN,KACnBuI,KAAI,SAAAsJ,GAAQ,OAAA3U,EAAK2V,qBAAqBhB,EAAK,IAC/D,IAAIpP,EAAiBmH,EAAM8M,EAAalX,EAAYK,EAAO,MAExE,OADAuG,GAAKzD,aAAegU,QAAkBzV,EAC/BkF,EACR,CAGD,GAAiC,MAA7B7G,EAAcM,EAAO,KAA4D,MAA7CN,EAAcM,EAAOA,EAAOG,OAAS,IAAa,CACxF,IAAM4W,GAAiBtW,EAAYT,EAAOkS,OAAO,EAAGlS,EAAOG,OAAS,GAAI,KAClEwE,GAAQ,GACd,IAAStE,EAAI,EAAGA,EAAI0W,GAAe5W,OAAQE,IAAK,CAC9C,IAAM2W,GAAWvW,EAAYsW,GAAe1W,GAAI,KAChD,GAAwB,IAApB2W,GAAS7W,OAAc,CACzB,IAAM8W,GAAQ,CACZxa,KAAM,IAAIwF,EAAU+U,GAAS,GAAG,IAChCpW,MAAOtD,KAAK0V,qBAAqBgE,GAAS,KAG5CrS,GAAMpE,KAAK0W,GACZ,KAAM,IAAwB,IAApBD,GAAS7W,OAwBlB,MAAMxC,MAAM,kBAvBZ,IAAIqK,GAAuB,KACrBkP,GAAWF,GAAS,GAE1B,GAAwB,IAApBE,GAAS/W,OACX6H,GAAO,IAAI/F,EAAUiV,GAAS,QACzB,IAC0B,MAA/BxX,EAAcwX,GAAS,KAC0B,MAAjDxX,EAAcwX,GAASA,GAAS/W,OAAS,IAIzC,MAAM,IAAIxC,MACR,4FAHFqK,GAAO1K,KAAK0V,qBAAqBkE,GAAS1W,MAAM,EAAG0W,GAAS/W,OAAS,GAKtE,CAEK8W,GAAQ,CACZxa,KAAIuL,GACJpH,MAAOtD,KAAK0V,qBAAqBgE,GAAS,KAG5CrS,GAAMpE,KAAK0W,GAGZ,CACF,CAED,OAAO,IAAIvS,EAAiBC,GAAOhF,EAAYK,EAAO,IACvD,CAGD,GAAiC,MAA7BN,EAAcM,EAAO,KAA4D,MAA7CN,EAAcM,EAAOA,EAAOG,OAAS,IAAa,CACxF,IAAM0E,GAAQpE,EAAYT,EAAOkS,OAAO,EAAGlS,EAAOG,OAAS,GAAI,KAAKuI,KAAI,SAAAsJ,GACtE,OAAA3U,EAAK2V,qBAAqBhB,EAA1B,IAGF,OAAO,IAAIpN,EAAgBC,GAAOlF,EAAYK,EAAO,IACtD,CAED,MAAMrC,MAAM,mBAAmBT,OAAAwC,EAAcM,EAAO,IAAO,QAE9DqR,CAAD,ICpuBM8F,GAA0C,CAC9C,KAAM,CAAC,MACP,IAAK,CAAC,IAAK,KAAM,MAEjB,IAAK,CAAC,IAAK,KAAM,MACjB,IAAK,CAAC,IAAK,KAAM,MACjB,IAAK,CAAC,IAAK,KAAM,MACjB,IAAK,CAAC,IAAK,KAAM,MAEjB,IAAK,CAAC,KACN,IAAK,CAAC,KACN,IAAK,CAAC,MACN,IAAK,CAAC,KACN,IAAK,CAAC,KAEN,IAAK,CAAC,IAAK,MACX,IAAK,CAAC,IAAK,KAAM,MAEjB,IAAK,CAAC,KACN,IAAK,CAAC,KACN,IAAK,CAAC,KACN,IAAK,CAAC,KACN,IAAK,CAAC,KACN,IAAK,CAAC,MAGFC,GAAc,CAAC,IAAK,IAAK,MACzBC,GAAqB,CAAC,QAAS,MAAO,MAAO,QAAS,KAAM,SAAU,MAE5EC,GAAA,WAAA,SAAAA,IACUha,KAAUia,WAAG,EACbja,KAAYka,aAAG,EACfla,KAAYma,aAAG,EACfna,KAAcoa,eAAG,EACjBpa,KAAUqa,WAAG,GACbra,KAAOsa,QAAG,EACVta,KAAOua,QAAG,EAyPnB,CAAD,OAvPEta,OAAAua,eAAYR,EAAS7Z,UAAA,YAAA,CAArBwI,IAAA,WACE,OAAO3I,KAAKqa,UACb,EACD5R,IAAA,SAAsBnF,IACftD,KAAKqa,YAAc/W,IACtBtD,KAAKia,WAAaja,KAAKma,aACvBna,KAAKka,aAAela,KAAKoa,gBAE3Bpa,KAAKqa,WAAa/W,CACnB,kCAMD0W,EAAQ7Z,UAAAsa,SAAR,SAASC,GACP,IAAKA,IAAWA,EAAO7X,OACrB,MAAO,GAGT6X,EAASA,EAENzI,QAAQ,IAAI0I,OAAO,KAAM,KAAM,MAE/B1I,QAAQ,IAAI0I,OAAO,KAAM,KAAM,IAClC3a,KAAKua,QAAUG,EAEf1a,KAAKsa,QAAU,EACfta,KAAKia,WAAa,EAClBja,KAAKka,aAAe,EACpBla,KAAKma,aAAe,EACpBna,KAAKoa,eAAiB,EAMtB,IAJA,IAAM1X,EAAkB,GAEpBkY,GAAQ,EAEoB,OAAzBF,EAAO1a,KAAKsa,UACjBta,KAAK6a,kBACDD,IACF5a,KAAKma,eACLS,GAAQ,GAEV5a,KAAKoa,eAAiB,EAGxB,EAAG,CACD,IAAMU,EAASJ,EAAO1a,KAAKsa,SAE3B,GAAc,KAAVQ,GAA2C,IAA1B9a,KAAK+a,UAAUlY,OAG7B,QAA8BkB,IAA1B8V,GAAciB,IAA0B9a,KAAKgb,eAAeF,EAAQpY,GAcxE,GAAe,MAAXoY,EAAgB,CAEzB,IADA,IAAIG,GAAQ,EAC8B,OAAnCP,EAAO1a,KAAK6a,qBACjB7a,KAAK+a,WAAaL,EAAO1a,KAAKsa,SAG1BW,IACFA,GAAQ,EACRjb,KAAKka,aAAela,KAAKka,aAAe,KAGtCla,KAAKsa,QAAU,GAAKI,EAAO7X,WAEjC7C,KAAK+a,UAAY/a,KAAKkb,aAAalb,KAAK+a,UAAWrY,GAAQ,EAAMhC,EAAWsU,QAC7E,MAAM,GAAe,MAAX8F,GAA6B,MAAXA,EAAgB,CAE3C,IAAMK,EAAIL,EAMV,GAHA9a,KAAK+a,UAAY/a,KAAKkb,aAAalb,KAAK+a,UAAWrY,GAG/CgY,EAAO1a,KAAKsa,QAAU,KAAOa,GAAKT,EAAO1a,KAAKsa,QAAU,KAAOa,EAAG,CACpE,IAAMC,EAAQpb,KAAKma,aACbkB,EAAUrb,KAAKoa,eACrBpa,KAAK6a,gBAAgB,GAErB,KACE7a,KAAK+a,WAAaL,EAAO1a,KAAK6a,qBAE5B7a,KAAKsa,QAAU,GAAKI,EAAO7X,QAC1B6X,EAAO1a,KAAKsa,QAAU,KAAOa,GAC5BT,EAAO1a,KAAKsa,QAAU,KAAOa,GAC7BT,EAAO1a,KAAKsa,QAAU,KAAOa,KAMnCnb,KAAKia,WAAamB,EAClBpb,KAAKka,aAAemB,EAEpBrb,KAAK6a,gBAAgB,EACtB,KAAM,CACL,KAAOH,EAAO1a,KAAK6a,qBAAuBM,GASxC,GAP2B,OAAzBT,EAAO1a,KAAKsa,UACZR,GAAYzK,QAAQqL,EAAO1a,KAAKsa,QAAU,KAAO,GAEjDta,KAAKsa,UAGPta,KAAK+a,WAAaL,EAAO1a,KAAKsa,SAC1Bta,KAAKsa,QAAU,GAAKI,EAAO7X,OAC7B,MAAM,IAAIxC,MAAM,QAAAT,OAAQI,KAAKia,WAAoC,6BAKrEja,KAAKka,cACN,CAG6B,IAA1Bla,KAAK+a,UAAUlY,SACjB7C,KAAKia,WAAaja,KAAKma,aACvBna,KAAKka,aAAela,KAAKoa,gBAE3Bpa,KAAK+a,UAAY/a,KAAKkb,aAAalb,KAAK+a,UAAWrY,GAAQ,EAAMhC,EAAW+C,cAC7E,KAAoB,KAAVqX,IACT9a,KAAK+a,WAAaD,OAnFoE,CAEtF9a,KAAK+a,UAAY/a,KAAKkb,aAAalb,KAAK+a,UAAWrY,GACnD1C,KAAK+a,UAAYD,EAEjB,IAAMQ,EAAUzB,GAAciB,GAE9B,GAAIQ,EAAQzY,QAAU,EAEpB,KAAOyY,EAAQ3Z,SAAS3B,KAAK+a,UAAYL,EAAO1a,KAAKsa,QAAU,KAC7Dta,KAAK+a,WAAaL,EAAO1a,KAAK6a,mBAGlC7a,KAAK+a,UAAY/a,KAAKkb,aAAalb,KAAK+a,UAAWrY,GAAQ,EAAOhC,EAAW6a,SAC9E,MAhBCvb,KAAK+a,UAAY/a,KAAKkb,aAAalb,KAAK+a,UAAWrY,EAuFtD,OAAQ1C,KAAK6a,kBAAoBH,EAAO7X,QAIzC,OAFA7C,KAAKkb,aAAalb,KAAK+a,UAAWrY,GAE3BA,GAGDsX,EAAe7Z,UAAA0a,gBAAvB,SAAwBW,QAAA,IAAAA,IAAAA,EAAS,GAC/B,IAAK,IAAIzY,EAAI,EAAGA,EAAIyY,EAAOzY,IACzB/C,KAAKsa,QAAUta,KAAKsa,QAAU,EACK,OAA/Bta,KAAKua,QAAQva,KAAKsa,UACpBta,KAAKma,eACLna,KAAKoa,eAAiB,GAEtBpa,KAAKoa,iBAIT,OAAOpa,KAAKsa,SAGNN,EAAA7Z,UAAAsb,eAAR,SACEV,EACA1W,QAAA,IAAAA,IAAAA,EAA8B,MAE9B,IAAIf,EAA0CyX,EAmB9C,OAjBa,OAAT1W,IACgB,SAAd0W,GACF1W,EAAO3D,EAAWqX,YAClBzU,EAAQ,MACe,SAAdyX,GAAsC,UAAdA,GACjC1W,EAAO3D,EAAWoX,YAClBxU,EAAsB,SAAdyX,GACuC,OAAtC/a,KAAK0b,kBAAkBX,IAChC1W,EAAO3D,EAAWmX,cAClBvU,EAAQtD,KAAK0b,kBAAkBX,IAE/B1W,EADS0V,GAAS1K,QAAQ0L,IAAc,EACjCra,EAAWib,QAEXjb,EAAWuX,YAIf,CACL3U,MAAOA,EACPe,KAAMA,IAIF2V,EAAY7Z,UAAA+a,aAApB,SACEU,EACAlZ,EACAmZ,EACAxX,GAGA,QAJA,IAAAwX,IAAAA,GAAwB,QACxB,IAAAxX,IAAAA,EAA8B,OAGxBuX,EAAS/Y,SAAWgZ,GAAkC,OAAbD,EAAmB,MAAO,GAEzE,IAAMzZ,EAAQnC,KAAKyb,eAAeG,EAAUvX,GAW5C,OAVA3B,EAAOO,KAAK,CACVd,EAAMmB,MACNwY,YAAYC,GACV5Z,EAAMkC,KACNrE,KAAKia,WACLja,KAAKka,aACLla,KAAKma,aACLna,KAAKoa,kBAGF,IAGDJ,EAAiB7Z,UAAAub,kBAAzB,SAA0BpY,GACxB,GAAqB,iBAAVA,EACT,OAAOA,EAGT,IAAKA,GAA0B,iBAAVA,EACnB,OAAO,KAMT,IAAK,IAAIP,GAHTO,EAAQA,EAAM0Y,QAGKnZ,OAAS,EAAGE,GAAK,EAAGA,IAAK,CAC1C,IAAMuP,EAAIhP,EAAM2Y,WAAWlZ,GAC3B,IAAIuP,EAAI,IAAMA,EAAI,KAEN,KAANA,GAAkB,KAANA,IAAmB,KAANA,GAAkB,IAANvP,GAAU,OAAO,IAE7D,CAED,IAAM8G,EAAMwI,WAAW/O,GACvB,OAAQwN,MAAMjH,GAAa,KAANA,GAGfmQ,EAAA7Z,UAAA6a,eAAR,SAAuBF,EAAgBoB,GACrC,GAAe,MAAXpB,IAAmB9a,KAAK+a,UAAUlY,OAAQ,CAE5C,IAAMsZ,EAAqC,IAAzBD,EAAcrZ,OAAeqZ,EAAcA,EAAcrZ,OAAS,GAAK,KACzF,OACgB,OAAdsZ,GACCja,EAAaia,KAAezb,EAAW6a,UAAyC,MAA7BnZ,EAAc+Z,EAErE,CAAM,MAAe,MAAXrB,GAA6D,OAA3C9a,KAAK0b,kBAAkB1b,KAAK+a,YAK5Df,CAAD,IC/QA,IAAAoC,GAAA,WAAA,SAAAA,IACmBpc,KAAYqI,aAAAE,EAAA,CAAA,EAAiCkI,IAEtDzQ,KAAqBqc,sBAAmC,IAqQjE,CAAD,OAhQSD,EAAAE,OAAP,WACE,OAAO,IAAIF,GAGbnc,OAAAua,eAAI4B,EAAuBjc,UAAA,0BAAA,CAA3BwI,IAAA,WACE,OAAO3I,KAAKqI,YACb,kCAEDpI,OAAAua,eAAI4B,EAAoBjc,UAAA,uBAAA,CAAxBwI,IAAA,WACE,OAAO3I,KAAKqc,qBACb,kCAEDD,EAAAjc,UAAAoc,QAAA,WACEvc,KAAKqc,sBAAwB,MAG/BD,EAAAjc,UAAAqc,aAAA,WACE,OAAO/L,GAAcC,YAGvB0L,EAAQjc,UAAAsa,SAAR,SAASC,GAEP,OADkB,IAAIV,IACLS,SAASC,IAG5B0B,EAAAjc,UAAAuO,MAAA,SAAMgM,EAAgB1S,QAAA,IAAAA,IAAAA,EAAwB,aAC5C,IAAMyU,EAAY,IAAIzC,GAGtB,OAFe,IAAIjG,IACIrF,MAAM+N,EAAUhC,SAASC,GAAS1S,IAI3DoU,EAAIjc,UAAAuc,KAAJ,SACEC,EACArU,EACAsU,EACA5U,QAFA,IAAAM,IAAAA,EAAmC,CAAA,QACnC,IAAAsU,IAAAA,EAAuD,SACvD,IAAA5U,IAAAA,EAAwB,aAExB,IAAMc,EACiB,iBAAd6T,EACH3c,KAAK0O,MAAMiO,EAAqB3U,GAC/B2U,EAED5T,EAAe,CACnBf,WAAYA,EACZG,kBAAmB,CAAEuB,QAAQ,GAC7BzB,WAAY,IAAIG,GAAME,IAGxBS,EAAad,WAAWQ,IAAI,yBAAyB,WACnD,OAAAqK,QAAQC,IAAIhK,EAAad,WAAWO,WAApC,IAEFO,EAAad,WAAWQ,IAAI,uBAAuB,WAAM,OAAAM,EAAad,WAAWO,UAAxB,IACzDxI,KAAKqc,sBAAwBtT,EAAad,WAAWO,WAErD,IAAM5F,GAAS,IAAIgG,IAAYC,UAAUC,EAAKC,GAC9C,GAAK6T,GAAsBA,EAAkB/Z,OAEtC,CACL,IAAMuS,EAAWvT,MAAMC,QAAQ8a,GAAoBA,EAAkB,GAAKA,EACpEC,EAAahb,MAAMC,QAAQ8a,GAAoBA,EAAkB1Z,MAAM,GAAK,GAC5EmH,EAAOtB,EAAad,WAAWU,IAAIyM,GACzC,GAAoB,mBAAT/K,EACT,MAAMhK,MAAM,YAAAT,OAAYgd,EAAiB,uCAE3C,OAAOvS,EAAQd,WAAA,EAAAsT,EAChB,CATC,OAAOja,GAYLwZ,EAASjc,UAAA2c,UAAf,SACEH,EACArU,EACAsU,EACA5U,EACA+U,eAHA,IAAAzU,IAAAA,EAAmC,CAAA,QACnC,IAAAsU,IAAAA,EAAuD,SACvD,IAAA5U,IAAAA,EAAwB,yHAwBT,OArBTc,EACiB,iBAAd6T,EACH3c,KAAK0O,MAAMiO,EAAqB3U,GAC/B2U,EACDK,EAAY,IAAIvP,GAChB1E,EAAe,CACnBf,WAAYA,EACZG,kBAAmB,CAAEuB,QAAQ,GAC7BzB,WAAY,IAAIG,GAAME,IAGM,mBAAnByU,GACTA,EAAehU,GAGjBA,EAAad,WAAWQ,IAAI,yBAAyB,WACnD,OAAAqK,QAAQC,IAAIhK,EAAad,WAAWO,WAApC,IAEFO,EAAad,WAAWQ,IAAI,uBAAuB,WAAM,OAAAM,EAAad,WAAWO,UAAxB,IACzDxI,KAAKqc,sBAAwBtT,EAAad,WAAWO,WAEtC,CAAA,EAAMwU,EAClBjP,wBACC,SAAOkP,GAAkB,OAAAC,EAAAnd,OAAA,OAAA,GAAA,6DACvB,MAAM,CAAA,EAACC,KAAKmd,aACRnd,KAAKmd,aAAaF,GAClBtP,QAAQC,OAAO,mCAFnB,KAAA,EAAA,MAAA,CAAA,EAAApE,oBAIHsE,sBAAqB,SAAMmP,GAAU,OAAAC,EAAAnd,OAAA,OAAA,GAAA,WAAA,OAAAqd,EAAApd,MAAA,SAAAwJ,mBAAI,KAAA,EAAA,MAAA,CAAA,EAAMxJ,KAAK0N,aAAauP,IAAxB,KAAA,EAAA,MAAA,CAAA,EAAAzT,oBACzCwE,6BAA4B,SAAChG,EAAYc,GAExC,IAAMuU,EAAatd,EAAKud,oBAAoBxU,EAAKR,GAC3CiV,EAAgB,CACpBvV,WAAUA,EACVC,WAAY,IAAIG,GAAMiV,GACtBlV,kBAAmBY,EAAaZ,mBAQlC,OANAoV,EAActV,WAAWQ,IAAI,yBAAyB,WACpD,OAAAqK,QAAQC,IAAIwK,EAActV,WAAWO,WAArC,IAEF+U,EAActV,WAAWQ,IAAI,uBAAuB,WAClD,OAAA8U,EAActV,WAAWO,UAAzB,IAEK+U,CACT,IACCrP,eAAepF,EAAKC,kBAxBjBnG,EAAS4G,EAwBqBoF,OAE/BgO,GAAsBA,EAAkB/Z,OAAM,CAAA,EAAA,GACjD,CAAA,EAAOD,UAMP,GAJMwS,EAAWvT,MAAMC,QAAQ8a,GAAoBA,EAAkB,GAAKA,EACpEC,EAAahb,MAAMC,QAAQ8a,GAAoBA,EAAkB1Z,MAAM,GAAK,GAG9D,mBADdmH,EAAOtB,EAAad,WAAWU,IAAIyM,IAEvC,MAAM/U,MAAM,YAAAT,OAAYgd,EAAiB,uCAEpC,MAAM,CAAA,EAAAvS,EAAQd,WAAA,EAAAsT,IAArB,KAAA,EAAA,MAAA,CAAA,EAAOrT,gBAEV,EAKK4S,EAAQjc,UAAAqd,SAAd,SACE9C,EACA3S,EACA6U,EACA5U,EACA+U,eAHA,IAAAhV,IAAAA,EAAqC,CAAA,QACrC,IAAA6U,IAAAA,EAAuD,SACvD,IAAA5U,IAAAA,EAAwB,wGAGxB,OAAK0S,GAAWA,EAAO7X,QAGjBiG,EAAM9I,KAAK0O,MAAMgM,EAAQ1S,GAE/BD,EAAUA,GAA8B,iBAAZA,EAAuBA,EAAU,CAAA,EAC7DA,EAAU/H,KAAKsd,oBAAoBxU,EAAKf,GAElC0V,EAAclV,OACfvI,KAAKqI,cACLN,GAGE,CAAA,EAAM/H,KAAK8c,UAAUhU,EAAK2U,EAAab,EAAmB5U,EAAY+U,KAZ3E,CAAA,EAAO,MAYT,KAAA,EAAA,MAAA,CAAA,EAAOvT,gBACR,EAED4S,EAAsBjc,UAAAud,uBAAtB,SAAuBC,GACrB,GAAsB,mBAAXA,EAGT,MAAMtd,MAAM,kBAEd,OAJEL,KAAK4d,cAAgBD,EAIhB3d,MAGToc,EAAoBjc,UAAA0d,qBAApB,SAAqBF,GACnB,GAAsB,mBAAXA,EAGT,MAAMtd,MAAM,qCAGd,OALEL,KAAKmd,aAAeQ,EAKf3d,MAGToc,EAAAjc,UAAA2d,YAAA,SACE1I,EACA2I,GAGA,OADA/d,KAAKqI,aAAa+M,GAAY2I,EACvB/d,MAGToc,EAAmBjc,UAAA6d,oBAAnB,SAAoBlS,GAElB,OADA7L,OAAOiK,OAAOlK,KAAKqI,aAAcyD,GAC1B9L,MAGToc,EAAAjc,UAAA8d,YAAA,SAAYC,EAAc9I,GACxB,YADU,IAAA8I,IAAAA,EAAY,IACfA,EAAQ7O,QAAQ,OAAAzP,OAAOwV,KAAe,GAGvCgH,EAAAjc,UAAAmd,oBAAR,SACExU,EACAf,GAEA,IAUMoW,EAFcrV,EAAIlC,KAAKuI,QAAO,SAAA9D,GAAK,MAAW,WAAXA,EAAEhH,IAAiB,IAGzD8K,QAAO,SAAAiP,GAAM,MAAkC,cAAlClf,EAAckf,EAAG5e,OAAOL,SACrCiM,KAAI,SAAAgT,GAAM,OAZS,SAACA,SACrB,MAAO,CACLjf,KAAMif,EAAG5e,OAAOL,KAChBkf,GAAID,EAAG5e,OAAOuN,MACduR,WAAoB,QAAR9U,EAAA4U,EAAGpX,aAAK,IAAAwC,OAAA,EAAAA,EAAE4B,KAAI,SAAAY,GAAK,OAAG7M,KAAM6M,EAAE7M,KAAMkf,GAAIrS,EAAEe,UAE1D,CAMawR,CAAcH,EAAG,IAE9B,GAAID,EAAStb,QAAU7C,KAAK4d,cAAe,CACzC,IAAMY,EAAYxe,KAAKye,gBAAgBN,GACvCpW,EAAeQ,EAAAA,EAAA,CAAA,EAAAR,GAAYyW,EAC5B,CAED,OAAOzW,GAGKqU,EAAYjc,UAAAuN,aAA1B,SAA2BuP,mGACzB,IAAKjd,KAAKmd,aACR,MAAM,IAAI9c,MAAM,mCAGF,MAAA,CAAA,EAAML,KAAKmd,aAAaF,WACxC,OADMyB,EAAUlV,EAAmCoF,OAC5C,CAAA,EAAA5O,KAAK0O,MAAMgQ,EAASzB,UAC5B,EAEOb,EAAejc,UAAAse,gBAAvB,SAAwBE,GAAxB,IAqBC5e,EAAAC,KApBC,IAAKA,KAAK4d,cACR,MAAMvd,MAAM,gCAEd,IAAMme,EAAqC,CAAA,EAgB3C,OAfAG,EAAS9J,SAAQ,SAACrL,GAAE,IAAArK,SAAMkf,EAAE7U,EAAA6U,GAAEC,EAAU9U,EAAA8U,WAChCM,EAAO7e,EAAK6d,eAAiB7d,EAAK6d,cAAcze,IAAU,IAC5Dmf,eAAAA,EAAYzb,QACdyb,EAAWzJ,SAAQ,SAAAgK,GACjBL,EAAUK,EAAKR,IAAMQ,EAAK1f,MAAQyf,EAAIC,EAAK1f,KAC7C,IACSkf,EACTG,EAAUH,GAAMO,EAEhBJ,EAAUrf,GAAQyf,EAEhBP,IACFG,EAAUH,GAAMO,EAEpB,IACOJ,GAEVpC,CAAD,IAAC0C,EAAA1C,YAAAA,GAAA0C,EAAApO,oBA3QC,OAAO0L,GAAYE,QACrB,CA0QC"}